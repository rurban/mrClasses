<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mrClasses: mr::PointCache class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>mr::PointCache Class Reference</h1><code>#include &lt;<a class="el" href="mrPointCache_8h-source.html">mrPointCache.h</a>&gt;</code>
<p>
<a href="classmr_1_1PointCache-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1PointCache.html#a0">flush</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush (Clean) the cache.  <a href="#a0"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1PointCache.html#a1">PointCache</a> (bool clean=true)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1PointCache.html#a2">~PointCache</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1PointCache.html#a3">insert</a> (const miVector &amp;P, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert user data into cache.  <a href="#a3"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1PointCache.html#a4">at</a> (const miVector &amp;P)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1PointCache.html#a5">operator[]</a> (const miVector &amp;P)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1PointCache.html#a6">data</a> (const miState *const state, T *data[3])</td></tr>

<tr><td colspan=2><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef std::map&lt; miVector,<br>
 void *, <a class="el" href="structmr_1_1lessXYZOp.html">lessXYZOp</a> &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1PointCache.html#x0">cacheType</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class allows you to cache arbitrary data and reference it by a vertex coordinate.<p>
This can be useful to obtain some of the benefits of a SIMD architecture within mental ray, by using a backdoor. But it could have other uses, too.<p>
Following is a description of usage for doing things that are usually (incorrectly) considered possible only on SIMD architectures. One of the big questions is whether you could do Du() or Dv() for any arbitrary expression, for example. The answer is usually, no. I'll now show you how.<p>
When an object is to be rendered, displacement shaders in mental ray are executed first, before any surface or light shaders. A displacement shader is usually run on every point, before other shaders are called (or in portions of the object, before those triangles are shaded).<p>
Thus, this gives you the chance to cache all those vertices and do some math or store some property. Note that displacement shaders are usually limited in not being able to raytrace (well, the mray manual says you can force mray to do it, but I have not tested this is safe).<p>
Anyway, after caching this data in the displacement shader, it would then later be used by, say, the surface shader. This can be passed using any of the mray mechanisms (static variables, state-&gt;user, shaderstate, or mi_query() for local shader data ).<p>
Then, in <a class="el" href="mrDerivs_8h.html">mrDerivs.h</a>, functions such as <a class="el" href="namespacemr.html#a42">DuDv()</a> can take that vertex data and use it to interpolate and give you (partial) derivatives, as prman. These derivatives will of course be accurate up to your tesselation rate, just as Du() is accurate up to shading rate in renderman.<p>
Note that it is important that you remember to flush this cache as it can grow to be quite big on complex scenes.<p>
See gg_pointcache.cpp example in the sample shader library, which contains gg_pointcache_srf, gg_pointcache_dsp shaders.<p>
Disadvantages of the method:<ul>
<li>Technique will not work for volume shaders.</li><li>Memory tracking. You need to flush your cache every now and then.</li><li>Can be used in displacement shaders, but you need an additional displacement shader. </li></ul>

<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="x0" doxytag="mr::PointCache::cacheType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef std::map&lt; miVector, void*, <a class="el" href="structmr_1_1lessXYZOp.html">lessXYZOp</a> &gt; <a class="el" href="classmr_1_1PointCache.html#x0">mr::PointCache::cacheType</a><code> [protected]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a1" doxytag="mr::PointCache::PointCache" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> mr::PointCache::PointCache </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>clean</em> = true          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor. Set Clean to true if <a class="el" href="classmr_1_1PointCache.html">PointCache</a> should delete stored void pointers automatically.     </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="mr::PointCache::~PointCache" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> mr::PointCache::~<a class="el" href="classmr_1_1PointCache.html">PointCache</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a4" doxytag="mr::PointCache::at" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* mr::PointCache::at </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miVector &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>P</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve user data for point from cache Will die if point is not in cache.     </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="mr::PointCache::data" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void mr::PointCache::data </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>[3]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve vertex data for vertices of current triangle from cache.     </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="mr::PointCache::flush" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void mr::PointCache::flush </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Flush (Clean) the cache. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="mr::PointCache::insert" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void mr::PointCache::insert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert user data into cache. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="mr::PointCache::operator[]" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* mr::PointCache::operator[] </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miVector &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>P</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve user data for point from cache Returns NULL if point is not in cache.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="mrPointCache_8h-source.html">mrPointCache.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sun Feb 22 18:29:27 2004 for mrClasses by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>

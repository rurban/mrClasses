<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mrClasses: mr Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>mr Namespace Reference</h1>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1buffer__base.html">buffer_base</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1color.html">color</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define main color class that replaces miColor. </em> <a href="structmr_1_1color.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1deleteMapIteratorData.html">deleteMapIteratorData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple functor class to delete Map Iterators. </em> <a href="structmr_1_1deleteMapIteratorData.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1deleteVectorIteratorData.html">deleteVectorIteratorData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple functor class to delete vector Iterators. </em> <a href="structmr_1_1deleteVectorIteratorData.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1diskSampler.html">diskSampler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sample in a disk. </em> <a href="classmr_1_1diskSampler.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1errorbuffer.html">errorbuffer</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1errorstream.html">errorstream</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1ExceptionHandler.html">ExceptionHandler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception handler. </em> <a href="classmr_1_1ExceptionHandler.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1fastmath.html">fastmath</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encapsulates fast math tables / functions. </em> <a href="classmr_1_1fastmath.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1fatalbuffer.html">fatalbuffer</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1fatalstream.html">fatalstream</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1FCell.html">FCell</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cellnoise class returning a float. </em> <a href="classmr_1_1FCell.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1FWorley.html">FWorley</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Worley noise class returning arbitrary number of floats. </em> <a href="classmr_1_1FWorley.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1hemisphereSampler.html">hemisphereSampler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sample a full or partial hemisphere around a direction. </em> <a href="classmr_1_1hemisphereSampler.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1infobuffer.html">infobuffer</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1infostream.html">infostream</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1lessTriOp.html">lessTriOp</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1lessUVOp.html">lessUVOp</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1lessXYZOp.html">lessXYZOp</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1math.html">math</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1math_3_01float_01_4.html">math&lt; float &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1matrix.html">matrix</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class to represent a matrix in mental ray. </em> <a href="classmr_1_1matrix.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1mutex.html">mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class used to create an autolock for multithreading by wrapping miLocks. </em> <a href="structmr_1_1mutex.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1normal__base.html">normal_base</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1point__base.html">point_base</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1PointCache.html">PointCache</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1progressbuffer.html">progressbuffer</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1progressstream.html">progressstream</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1sampler.html">sampler</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1sampler3D.html">sampler3D</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1simple__timer.html">simple_timer</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1SPerlin.html">SPerlin</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perlin Class returning a miScalar. </em> <a href="classmr_1_1SPerlin.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1sphereSampler.html">sphereSampler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sample spherically or partially around a sphere. </em> <a href="classmr_1_1sphereSampler.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1timer.html">timer</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1TriangleVertexCache.html">TriangleVertexCache</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1triId.html">triId</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identifies a triangle, as in miState, but smaller. </em> <a href="structmr_1_1triId.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1UVCache.html">UVCache</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1VCell.html">VCell</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cellnoise class returning a vector. </em> <a href="classmr_1_1VCell.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1vec__base.html">vec_base</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1vecnorm.html">vecnorm</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classmr_1_1VPerlin.html">VPerlin</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perlin Class returning a vector. </em> <a href="classmr_1_1VPerlin.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1warningbuffer.html">warningbuffer</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structmr_1_1warningstream.html">warningstream</a></td></tr>

<tr><td colspan=2><br><h2>clamp</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const miScalar&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a63">clamp</a> (const miScalar x, const miScalar minVal, const miScalar maxVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clamp X based on a min and max value.  <a href="#a63"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T&gt; const T &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a64">clamp</a> (const T &amp;x, const T &amp;minVal, const T &amp;maxVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clamp X based on a min and max value.  <a href="#a64"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T&gt; T&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a65">clamp</a> (const T &amp;x, const T &amp;minVal, const miScalar maxVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clamp X based on a similar min but max scalar value.  <a href="#a65"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T&gt; T&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a66">clamp</a> (const T &amp;x, const miScalar minVal, const T &amp;maxVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clamp X based on a scalar min but similar max value.  <a href="#a66"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T&gt; T&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a67">clamp</a> (const T &amp;x, const miScalar minVal=0.0f, const miScalar maxVal=1.0f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clamp X based on a two scalar values.  <a href="#a67"></a><br><br></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef const char *const &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a0">kNoConstruct</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef std::map&lt; <a class="el" href="structmr_1_1vec__base.html">vector</a>,<br>
 <a class="el" href="structmr_1_1color.html">color</a> *, <a class="el" href="structmr_1_1lessXYZOp.html">lessXYZOp</a> &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a2">vertex_color_cache</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef basic_stringbuf&lt; char,<br>
 std::char_traits&lt; char &gt;,<br>
 std::allocator&lt; char &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a4">mr_string_stream</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structmr_1_1normal__base.html">normal_base</a>&lt; miVector,<br>
 miScalar &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a11">normal</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structmr_1_1point__base.html">point_base</a>&lt; miVector,<br>
 miScalar &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a12">point</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structmr_1_1vec__base.html">vec_base</a>&lt; miVector,<br>
 miScalar &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a13">vector</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structmr_1_1vec__base.html">vec_base</a>&lt; miVector,<br>
 miScalar &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a14">Vector</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structmr_1_1vec__base.html">vec_base</a>&lt; miGeoVector,<br>
 miGeoScalar &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a15">geovector</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structmr_1_1base_1_1vec2.html">base::vec2</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a16">vector2d</a></td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a17">linear_bump</a> (miState *const state, <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;dPds, <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;dPdt, const miScalar gradu, const miScalar gradv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform Linear bump mapping.  <a href="#a17"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a18">deriv_bump</a> (const <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;N, <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;dPds, <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;dPdt, const miScalar gradu, const miScalar gradv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform Derivative bump mapping.  <a href="#a18"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a19">bump</a> (miState *const state, const <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;dPds, const <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;dPdt, const miScalar gradu, const miScalar gradv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform Blinn bump mapping.  <a href="#a19"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a20">parallax_bump</a> (miVector2d &amp;offset, const miState *const state, const miScalar amt, const miScalar scale, const miScalar bias=0.5f, const int idx=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a21">parallax_bump</a> (const miState *const state, const miScalar amt, const miScalar scale, const miScalar bias=0.5f, const int idx=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a22">calculatenormal</a> (miState *const state, const <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;dPds, const <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;dPdt)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a23">calculatenormal</a> (miState *const state)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a24">get_normals</a> (const miState *const state, miVector N[3])</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a25">get_vertices</a> (const miState *const state, miVector v[3])</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a26">check_bary_bounds</a> (miScalar b[3])</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a27">calculate_bary</a> (miScalar b[3], const <a class="el" href="structmr_1_1point__base.html">point</a> &amp;p, const miVector v[3])</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a28">calculate_bary</a> (miScalar bary[3], const miState *const state, const <a class="el" href="structmr_1_1point__base.html">point</a> &amp;p)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a29">calculate_bary2</a> (miScalar bx[3], miScalar by[3], const miState *const state, const <a class="el" href="structmr_1_1point__base.html">point</a> &amp;px, const <a class="el" href="structmr_1_1point__base.html">point</a> &amp;py)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Auxiliary routine to take two points and return their barycentric coords.  <a href="#a29"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>miScalar&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a30">area</a> (const miState *const state)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miScalar&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a31">areaSquared</a> (const miState *const state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as area, but squared.  <a href="#a31"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>miScalar&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a32">area</a> (const miState *const state, const miVector &amp;P)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miScalar&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a33">areatriangle</a> (const miState *const state)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miScalar&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a34">areatriangleSquared</a> (const miState *const state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as areatriangle, but squared.  <a href="#a34"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a35">get_sides</a> (const miState *const state, int &amp;w, int &amp;h)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a36">DuDv_Impl</a> (T &amp;Du, T &amp;Dv, const miState *state, const miScalar u1, const miScalar u2, const miScalar v1, const miScalar v2, const T data[3], const int idx=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a37">DuDv_Impl</a> (<a class="el" href="structmr_1_1color.html">color</a> &amp;Du, <a class="el" href="structmr_1_1color.html">color</a> &amp;Dv, const miState *state, const miScalar u1, const miScalar u2, const miScalar v1, const miScalar v2, const <a class="el" href="structmr_1_1color.html">color</a> data[3], const int idx)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a38">DuDv_Impl</a> (<a class="el" href="structmr_1_1base_1_1vec2.html">vector2d</a> &amp;Du, <a class="el" href="structmr_1_1base_1_1vec2.html">vector2d</a> &amp;Dv, const miState *state, const miScalar u1, const miScalar u2, const miScalar v1, const miScalar v2, const <a class="el" href="structmr_1_1base_1_1vec2.html">vector2d</a> data[3], const int idx)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a39">DuDv_Impl</a> (miScalar &amp;Du, miScalar &amp;Dv, const miState *state, const miScalar u1, const miScalar u2, const miScalar v1, const miScalar v2, const miScalar data[3], const int idx)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a40">DuDv_Impl</a> (T &amp;Du, T &amp;Dv, const miState *state, const miScalar bx[3], const miScalar by[3], const T data[3], const int idx=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates auxiliary determinants then goes to calculate Du,Dv.  <a href="#a40"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a41">DuDv_Impl</a> (T &amp;Du, T &amp;Dv, miScalar &amp;du, miScalar &amp;dv, const miState *state, const miScalar bx[3], const miScalar by[3], const T data[3], const int idx=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates du, dv then goes to calculate Du,Dv.  <a href="#a41"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a42">DuDv</a> (T &amp;Du, T &amp;Dv, miScalar &amp;du, miScalar &amp;dv, const miState *state, const <a class="el" href="structmr_1_1point__base.html">point</a> &amp;Px, const <a class="el" href="structmr_1_1point__base.html">point</a> &amp;Py, const T data[3], const int idx=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a43">DuDv</a> (T &amp;Du, T &amp;Dv, miScalar &amp;du, miScalar &amp;dv, const miState *state, const T tri_data[3], const int idx=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a44">DuDv</a> (T &amp;Du, T &amp;Dv, const miState *state, const <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;Px, const <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;Py, const T data[3], const int idx=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a45">DuDv</a> (T &amp;Du, T &amp;Dv, const miState *state, const T tri_data[3], const int idx=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a46">DsuDtv</a> (const miState *const state, miScalar &amp;DuS, miScalar &amp;DvS, miScalar &amp;DuT, miScalar &amp;DvT, const int STidx=0, const int UVidx=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like DuDv, but returning Du(s)*du, Dv(s)*dv and Du(t)*du, Dv(t)*dv.  <a href="#a46"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a47">dPdst</a> (miVector &amp;dPds, miVector &amp;dPdt, const miState *const state, const int idx=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a48">dNdst</a> (miVector &amp;dNds, miVector &amp;dNdt, const miState *const state, const int idx=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a49">dPNdst</a> (miVector &amp;dPds, miVector &amp;dPdt, miVector &amp;dNds, miVector &amp;dNdt, const miState *const state, const int idx=0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a50">dPduv</a> (miVector &amp;dPdu, miVector &amp;dPdv, const miState *const state)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a51">BumpUV</a> (miVector &amp;dPdu, miVector &amp;dPdv, const miState *const state, const int idx=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get bump basis for a texture index.  <a href="#a51"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>miBoolean&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a52">dPduv2</a> (miVector &amp;dP2du2, miVector &amp;dP2dv2, miVector &amp;dP2dudv, const miState *const state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get second order derivatives d2x/du2, d2x/dv2, d2x/dudv.  <a href="#a52"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; const T &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a53">min</a> (const T &amp;x, const T &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Auxiliary function to return min of 2 elements.  <a href="#a53"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; const T &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a54">min</a> (const T &amp;x, const T &amp;y, const T &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Auxiliary function to return min of 3 elements.  <a href="#a54"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; const T &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a55">min</a> (const T &amp;w, const T &amp;x, const T &amp;y, const T &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Auxiliary function to return min of 4 elements.  <a href="#a55"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; const T &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a56">max</a> (const T &amp;x, const T &amp;y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Auxiliary function to return max of 2 elements.  <a href="#a56"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; const T &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a57">max</a> (const T &amp;x, const T &amp;y, const T &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Auxiliary function to return max of 3 elements.  <a href="#a57"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; const T &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a58">max</a> (const T &amp;w, const T &amp;x, const T &amp;y, const T &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Auxiliary function to return max of 4 elements.  <a href="#a58"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a59">minmax</a> (T &amp;minst, T &amp;maxst, const T &amp;s0, const T &amp;s1, const T &amp;s2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a60">isEquivalent</a> (const T v, const T x, const T eps=miSCALAR_EPSILON)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a61">isEquivalent</a> (const miGeoScalar v, const miGeoScalar x, const miGeoScalar eps=miGEO_SCALAR_EPSILON)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T&gt; int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a62">round</a> (const T &amp;x)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a68">connected</a> (const miState *const s, const T &amp;p)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; const T &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a69">eval</a> (const miState *const state, const T &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simpler mi_eval_* for shaders' use.  <a href="#a69"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; const T *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a70">eval</a> (const miState *const state, const T *v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simpler mi_eval_* for shaders' use.  <a href="#a70"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a71">blinn_coeffs</a> (miScalar &amp;NdH, miScalar &amp;VdH, const <a class="el" href="structmr_1_1normal__base.html">normal</a> &amp;N, const <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;L, const <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;V, const miScalar NdL, const miScalar NdV)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miScalar&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a72">G_attenuation</a> (const miScalar NdV, const miScalar NdL, const miScalar NdH, const miScalar VdH)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miScalar&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a73">G_attenuation_pixar</a> (const miScalar NdV, const miScalar NdL, const miScalar NdH, const miScalar VdH)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miScalar&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a74">Trowbridge_Reitz</a> (const miScalar NdH, const miScalar k2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miScalar&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a75">Torrance_Sparrow</a> (const miScalar NdH, const miScalar k1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miScalar&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a76">Beckmann</a> (const miScalar NdH, const miScalar m)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miScalar&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a77">Phong</a> (const <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;V, const <a class="el" href="structmr_1_1normal__base.html">normal</a> &amp;N, const <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;L, const miScalar NdL, const miScalar shiny)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>miScalar&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a78">Blong</a> (const <a class="el" href="structmr_1_1normal__base.html">normal</a> &amp;N, const <a class="el" href="structmr_1_1vec__base.html">vector</a> &amp;H, const miScalar shiny)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T&gt; T&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a79">spline</a> (const miScalar f, const std::vector&lt; T &gt; &amp;args, const <a class="el" href="namespacemr_1_1basis.html#a8">basis::type</a> b=basis::kCatmullRom)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T&gt; T&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a80">spline</a> (const miScalar f, const unsigned num, const T *const args, const <a class="el" href="namespacemr_1_1basis.html#a8">basis::type</a> b=basis::kCatmullRom)</td></tr>

<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const char *const &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a1">kNoInit</a> = ""</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>const miScalar&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a3">kNotCached</a> = -255.0f</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>MR_LIB_EXPORT <a class="el" href="structmr_1_1mutex.html">mutex</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a5">streamMutex</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structmr_1_1infostream.html">infostream</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a6">info</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structmr_1_1warningstream.html">warningstream</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a7">warning</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structmr_1_1errorstream.html">errorstream</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a8">error</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structmr_1_1fatalstream.html">fatalstream</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a9">fatal</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structmr_1_1progressstream.html">progressstream</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacemr.html#a10">progress</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Just a simple include that adds most typical settings needed for all other classes to function properly 
<p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a15" doxytag="mr::geovector" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="structmr_1_1vec__base.html">vec_base</a>&lt; miGeoVector, miGeoScalar &gt; <a class="el" href="structmr_1_1vec__base.html">mr::geovector</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="mr::kNoConstruct" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef const char* const <a class="el" href="namespacemr.html#a0">mr::kNoConstruct</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This typedef/static const will be used to create constructors that do not init their values. Example: color x( kNoInit );     </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="mr::mr_string_stream" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef basic_stringbuf&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; <a class="el" href="namespacemr.html#a4">mr::mr_string_stream</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="mr::normal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="structmr_1_1normal__base.html">normal_base</a>&lt; miVector, miScalar &gt; <a class="el" href="structmr_1_1normal__base.html">mr::normal</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="mr::point" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="structmr_1_1point__base.html">point_base</a>&lt; miVector, miScalar &gt; <a class="el" href="structmr_1_1point__base.html">mr::point</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="mr::Vector" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="structmr_1_1vec__base.html">vec_base</a>&lt; miVector, miScalar &gt; <a class="el" href="structmr_1_1vec__base.html">mr::Vector</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="mr::vector" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="structmr_1_1vec__base.html">vec_base</a>&lt; miVector, miScalar &gt; <a class="el" href="structmr_1_1vec__base.html">mr::vector</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="mr::vector2d" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="structmr_1_1base_1_1vec2.html">base::vec2</a> <a class="el" href="structmr_1_1base_1_1vec2.html">mr::vector2d</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="mr::vertex_color_cache" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef std::map&lt; <a class="el" href="structmr_1_1vec__base.html">vector</a>, <a class="el" href="structmr_1_1color.html">color</a>*, <a class="el" href="structmr_1_1lessXYZOp.html">lessXYZOp</a> &gt; <a class="el" href="namespacemr.html#a2">mr::vertex_color_cache</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a32" doxytag="mr::area" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miScalar area </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>P</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>: test if this area(P) works at all</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="mr::area" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miScalar area </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miState *const&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>state</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Raster area -ie. pixel footprint - ( more similar to what shader writers expect from prman's <a class="el" href="namespacemr.html#a30">area()</a> ).<p>
Use areaTriangle(state) for area of actual (micro)triangle     </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="mr::areaSquared" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miScalar areaSquared </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miState *const&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>state</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as area, but squared. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="mr::areatriangle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miScalar areatriangle </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miState *const&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>state</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the squared area of the (micro)triangle. Note that this can be different from the pixel footprint, even if in Prman this is one and the same. Use area(state) for pixel area     </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="mr::areatriangleSquared" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miScalar areatriangleSquared </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miState *const&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>state</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as areatriangle, but squared. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a76" doxytag="mr::Beckmann" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miScalar Beckmann </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>NdH</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>m</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Given the dot product of the normal and the half vector H, and a scalar value, calculate the Beckmann (aka. Cook-Torrance) specular spread.<p>
D = _________ 1 ____________ 2 -[(tan B)/m] 2 4 e 4m cos B     </td>
  </tr>
</table>
<a class="anchor" name="a71" doxytag="mr::blinn_coeffs" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void blinn_coeffs </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miScalar &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>NdH</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miScalar &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>VdH</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const normal &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>N</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>V</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>NdL</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>NdV</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is a faster way to calculate NdH and VdH.<p>
Given the normal, position of a light(L) and the incident vector (V), and the dot products of N.L (from mi_sample_light) and N.V (from miState), this routine returns the dot products with the half vector: N.H and V.H.<p>
This is faster than calculating H, normalizing it and then doing two dot products.<p>
For explanation and derivation, see: GRAPHICS GEMS I: Fast Dot Products for Shading.     </td>
  </tr>
</table>
<a class="anchor" name="a78" doxytag="mr::Blong" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miScalar Blong </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const normal &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>N</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>H</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>shiny</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Given a normal, the half-vector (blinn_coeff) H, and a scalar value, calculate blinn's phong specular, defined as:<p>
D = (N.H)^shiny<p>
This is Softimage's phong.     </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="mr::bump" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void bump </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPds</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPdt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>gradu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>gradv</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform Blinn bump mapping. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a51" doxytag="mr::BumpUV" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miBoolean BumpUV </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPdu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPdv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get bump basis for a texture index. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="mr::calculate_bary" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miBoolean calculate_bary </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>bary</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const point &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="mr::calculate_bary" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miBoolean calculate_bary </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const point &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miVector&nbsp;</td>
          <td class="mdname" nowrap> <em>v</em>[3]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is from comp.graphics.algorithms, old post of Rod Bogart.<p>
Given an arbitrary point in the plane of the triangle, calculate its barycentric coordinates. Returns miFALSE if point is outside triangle.<p>
1 If the area of triangle 123 is A, then the area of /|\ P23 is rA. Area 12P is sA and area 1P3 is tA. / | \ With this image, it is obvious that r+s+t must equal / | \ one. If r, s, or t go outside the range zero to one, / t | s \ P will be outside the triangle. / _-P-_ \ / _- -_ \ /_- r -_\ 3---------------2 N = triangle normal = (vec(1 2) cross vec(1 3))<p>
(vec(1 P) cross vec(1 3)) dot N s = ------------------------------- length N<p>
(vec(1 2) cross vec(1 P)) dot N t = ------------------------------- length N<p>
r = 1 - (s + t)<p>
Note that equation as published in the email is kind of incomplete. dot N assumes that N is normalized. Code below does that.     </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="mr::calculate_bary2" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void calculate_bary2 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>bx</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>by</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const point &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>px</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const point &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>py</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Auxiliary routine to take two points and return their barycentric coords. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="mr::calculatenormal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void calculatenormal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miState *const&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>state</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Recalculate and renormalize normal for Blinn/Linear bump mapping To be used only for bump mapping (displacement shaders do not need this)     </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="mr::calculatenormal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void calculatenormal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPds</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPdt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Recalculate and renormalize normal for rotational bump map To be used only for bump mapping (displacement shaders do not need this)     </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="mr::check_bary_bounds" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void check_bary_bounds </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miScalar&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>b</em>[3]          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Auxiliary routine to check barycentric coordinates to be in [0,1] range for derivatives.     </td>
  </tr>
</table>
<a class="anchor" name="a67" doxytag="mr::clamp" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> T clamp </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>minVal</em> = 0.0f, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>maxVal</em> = 1.0f</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clamp X based on a two scalar values. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a66" doxytag="mr::clamp" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> T clamp </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>minVal</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>maxVal</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clamp X based on a scalar min but similar max value. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a65" doxytag="mr::clamp" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> T clamp </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>minVal</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>maxVal</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clamp X based on a similar min but max scalar value. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a64" doxytag="mr::clamp" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const T&amp; clamp </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>minVal</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>maxVal</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clamp X based on a min and max value. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a63" doxytag="mr::clamp" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const miScalar clamp </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>minVal</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>maxVal</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clamp X based on a min and max value. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a68" doxytag="mr::connected" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bool connected </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Undocumented way of determining whether a parameter is connected into a shader tree. This is what mi_eval() does behind the scenes, basically.     </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="mr::deriv_bump" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void deriv_bump </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>N</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPds</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPdt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>gradu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>gradv</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform Derivative bump mapping. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a48" doxytag="mr::dNdst" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miBoolean dNdst </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dNds</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dNdt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate dNds and dNdt for the state-&gt;point intersection. idx controls the texture vectors.     </td>
  </tr>
</table>
<a class="anchor" name="a47" doxytag="mr::dPdst" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miBoolean dPdst </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPds</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPdt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate dPds and dPdt for the state-&gt;point intersection. idx controls the texture vectors (for when surface has multiple STs)     </td>
  </tr>
</table>
<a class="anchor" name="a50" doxytag="mr::dPduv" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miBoolean dPduv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPdu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPdv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate dPdu and dPdv for the state-&gt;point intersection. idx controls the texture vectors (for when surface has multiple STs)     </td>
  </tr>
</table>
<a class="anchor" name="a52" doxytag="mr::dPduv2" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miBoolean dPduv2 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dP2du2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dP2dv2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dP2dudv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get second order derivatives d2x/du2, d2x/dv2, d2x/dudv. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a49" doxytag="mr::dPNdst" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miBoolean dPNdst </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPds</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPdt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dNds</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miVector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dNdt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate dPds, dPdt, dNds and dNdt for the state-&gt;point intersection. idx controls the texture vectors (for when surface has multiple STs)     </td>
  </tr>
</table>
<a class="anchor" name="a46" doxytag="mr::DsuDtv" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void DsuDtv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miScalar &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>DuS</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miScalar &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>DvS</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miScalar &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>DuT</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miScalar &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>DvT</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>STidx</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>UVidx</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Like DuDv, but returning Du(s)*du, Dv(s)*dv and Du(t)*du, Dv(t)*dv. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a45" doxytag="mr::DuDv" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> miBoolean DuDv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Du</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Dv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T&nbsp;</td>
          <td class="mdname" nowrap> <em>tri_data</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate Du(data) and Dv(data).<p>
Du, Dv are the derivatives of data in u and v (ie. Du(data), Dv(data)).<p>
This is similar to prman's Du() and Dv() functions. Accuracy of partial derivatives will be dependant on surface tesselation.<p>
tri_data[3] is the data to interpolate. Each index corresponds to a vertex of the triangle, in the order of mi_tri_vectors. idx is the texture index (state-&gt;tex_list[]) to be used as UV.<p>
To create tri_data[] when problem cannot be solved analitically, you can use a dummy displacement shader to evaluate and store the result for each vertex. See <a class="el" href="mrPointCache_8h.html">mrPointCache.h</a>     </td>
  </tr>
</table>
<a class="anchor" name="a44" doxytag="mr::DuDv" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> miBoolean DuDv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Du</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Dv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Px</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Py</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate Du(data) and Dv(data) from 3 positions.<p>
Du, Dv are the derivatives of data in u and v (ie. Du(data), Dv(data)).<p>
Px is the point offset. Usually, this is state-&gt;point + mi_raster_unit(..,X,..) Py is the other point offset. Usually, this is state-&gt;point + mi_raster_unit(..,..,Y) data[3] is the data to interpolate. data[0] is the data for current point (state-&gt;point) data[1] is the data for point Px data[2] is the data for point Py idx is the texture index (state-&gt;tex_list[]) to be used as UV.     </td>
  </tr>
</table>
<a class="anchor" name="a43" doxytag="mr::DuDv" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> miBoolean DuDv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Du</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Dv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miScalar &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>du</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miScalar &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T&nbsp;</td>
          <td class="mdname" nowrap> <em>tri_data</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate Du(data), du and Dv(data), dv.<p>
Du, Dv are the derivatives of data in u and v (ie. Du(data), Dv(data)). du, dv are the derivatives of u and v.<p>
This is similar to prman's Du() and Dv() functions. Accuracy of partial derivatives will be dependant on surface tesselation.<p>
tri_data[3] is the data to interpolate. Each index corresponds to a vertex of the triangle, in the order of mi_tri_vectors. idx is the texture index (state-&gt;tex_list[]) to be used as UV.<p>
To create tri_data[] when problem cannot be solved analitically, you can use a dummy displacement shader to evaluate and store the result for each vertex. See <a class="el" href="mrPointCache_8h.html">mrPointCache.h</a>     </td>
  </tr>
</table>
<a class="anchor" name="a42" doxytag="mr::DuDv" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> miBoolean DuDv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Du</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Dv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miScalar &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>du</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miScalar &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const point &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Px</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const point &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Py</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate Du(data), du and Dv(data), dv.<p>
Du, Dv are the derivatives of data in u and v (ie. Du(data), Dv(data)). du, dv are the derivatives of u and v.<p>
This is similar to prman's Du() and Dv() functions. Accuracy of partial derivatives will be dependant on surface tesselation.<p>
data[3] is the data to interpolate. Each index corresponds to a vertex. data[0] corresponds to state-&gt;point, data[1] corresponds to Px, data[2] corresponds to Py. idx is the texture index (state-&gt;tex_list[]) to be used as UV.     </td>
  </tr>
</table>
<a class="anchor" name="a41" doxytag="mr::DuDv_Impl" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> miBoolean DuDv_Impl </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Du</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Dv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miScalar &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>du</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miScalar &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>bx</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>by</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates du, dv then goes to calculate Du,Dv. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a40" doxytag="mr::DuDv_Impl" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> miBoolean DuDv_Impl </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Du</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Dv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>bx</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>by</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates auxiliary determinants then goes to calculate Du,Dv. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a39" doxytag="mr::DuDv_Impl" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miBoolean DuDv_Impl </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miScalar &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Du</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miScalar &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Dv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>u1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>u2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>v1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>v2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate Du(data), du and Dv(data), dv.<p>
Internal function not for user consumption.     </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="mr::DuDv_Impl" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miBoolean DuDv_Impl </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">vector2d &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Du</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>vector2d &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Dv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>u1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>u2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>v1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>v2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const vector2d&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate Du(data), du and Dv(data), dv.<p>
Internal function not for user consumption.     </td>
  </tr>
</table>
<a class="anchor" name="a37" doxytag="mr::DuDv_Impl" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miBoolean DuDv_Impl </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">color &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Du</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>color &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Dv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>u1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>u2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>v1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>v2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const color&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate Du(data), du and Dv(data), dv.<p>
Internal function not for user consumption.     </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="mr::DuDv_Impl" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> miBoolean DuDv_Impl </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Du</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Dv</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>u1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>u2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>v1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>v2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>[3], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate Du(data), du and Dv(data), dv.<p>
Internal function not for user consumption.     </td>
  </tr>
</table>
<a class="anchor" name="a70" doxytag="mr::eval" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const T* eval </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T *&nbsp;</td>
          <td class="mdname" nowrap> <em>v</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Simpler mi_eval_* for shaders' use. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a69" doxytag="mr::eval" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const T&amp; eval </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>v</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Simpler mi_eval_* for shaders' use. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a72" doxytag="mr::G_attenuation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miScalar G_attenuation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>NdV</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>NdL</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>NdH</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>VdH</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Specular G(eometric) attenuation<p>
In Foley-VanDamm, it is:<p>
G = min( 1, 2*NdH*NdV/VdH, 2*NdH*NdL/VdH );<p>
But Pixar in MTOR uses a similar but slightly different construct, which is the one below.     </td>
  </tr>
</table>
<a class="anchor" name="a73" doxytag="mr::G_attenuation_pixar" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miScalar G_attenuation_pixar </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>NdV</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>NdL</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>NdH</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>VdH</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Specular G(eometric) attenuation a la pixar     </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="mr::get_normals" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void get_normals </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miVector&nbsp;</td>
          <td class="mdname" nowrap> <em>N</em>[3]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Auxiliary routine to get triangle normals and take them to internal space, normalizing them also.     </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="mr::get_sides" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void get_sides </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>w</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>h</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Auxiliary routine to find the two indices to the sides of the triangle (ie. disregard hypotenuse)     </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="mr::get_vertices" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void get_vertices </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>miVector&nbsp;</td>
          <td class="mdname" nowrap> <em>v</em>[3]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Auxiliary routine to get triangle vertices and take them to internal space.     </td>
  </tr>
</table>
<a class="anchor" name="a61" doxytag="mr::isEquivalent" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool isEquivalent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miGeoScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>v</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miGeoScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miGeoScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>eps</em> = miGEO_SCALAR_EPSILON</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a60" doxytag="mr::isEquivalent" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bool isEquivalent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T&nbsp;</td>
          <td class="mdname" nowrap> <em>v</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T&nbsp;</td>
          <td class="mdname" nowrap> <em>eps</em> = miSCALAR_EPSILON</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="mr::linear_bump" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void linear_bump </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPds</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dPdt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>gradu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>gradv</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform Linear bump mapping. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a58" doxytag="mr::max" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const T&amp; max </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>w</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>z</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Auxiliary function to return max of 4 elements. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a57" doxytag="mr::max" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const T&amp; max </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>z</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Auxiliary function to return max of 3 elements. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a56" doxytag="mr::max" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const T&amp; max </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Auxiliary function to return max of 2 elements. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a55" doxytag="mr::min" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const T&amp; min </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>w</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>z</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Auxiliary function to return min of 4 elements. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a54" doxytag="mr::min" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const T&amp; min </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>z</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Auxiliary function to return min of 3 elements. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a53" doxytag="mr::min" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const T&amp; min </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Auxiliary function to return min of 2 elements. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a59" doxytag="mr::minmax" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void minmax </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>minst</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>maxst</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s0</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Auxiliary function to return min/max of 3 numbers. A tad faster than using <a class="el" href="namespacemr.html#a56">max()</a> and <a class="el" href="namespacemr.html#a53">min()</a> separately     </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="mr::parallax_bump" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void parallax_bump </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>amt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>bias</em> = 0.5f, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="mr::parallax_bump" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void parallax_bump </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">miVector2d &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>offset</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miState *const&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>amt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>bias</em> = 0.5f, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>idx</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform parallax bump mapping This routine will modify all state-&gt;tex_list[] coordinates. See: <a href="http://vrsj.t.u-tokyo.ac.jp/ic-at/papers/01205.pdf">http://vrsj.t.u-tokyo.ac.jp/ic-at/papers/01205.pdf</a>     </td>
  </tr>
</table>
<a class="anchor" name="a77" doxytag="mr::Phong" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miScalar Phong </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>V</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const normal &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>N</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const vector &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>NdL</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>shiny</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Given the view vector, a normal, the light vector, and a scalar value, calculate the (original) phong specular spread.     </td>
  </tr>
</table>
<a class="anchor" name="a62" doxytag="mr::round" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> int round </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>x</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a80" doxytag="mr::spline" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> T spline </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>f</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>num</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T *const&nbsp;</td>
          <td class="mdname" nowrap> <em>args</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const basis::type&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em> = basis::kCatmullRom</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Evaluate a spline function in the range f=[0,1]. You need to pass at least 4 arguments for the spline. If basis b is kLinear, the first and last argument are unused. If basis is not specified, default to kCatmullRom.     </td>
  </tr>
</table>
<a class="anchor" name="a79" doxytag="mr::spline" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> T spline </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>f</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const std::vector&lt; T &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>args</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const basis::type&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em> = basis::kCatmullRom</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Evaluate a spline function in the range f=[0,1]. You need to pass at least 4 arguments for the spline. If basis b is kLinear, the first and last argument are unused. If basis is not specified, default to kCatmullRom.     </td>
  </tr>
</table>
<a class="anchor" name="a75" doxytag="mr::Torrance_Sparrow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miScalar Torrance_Sparrow </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>NdH</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>k1</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Given the dot product of N.H, and a scalar value, calculate the Torrance-Sparrow specular spread.<p>
exp(-( pow(k1 * acos(N.H)),2))<p>
where k1 is a user defined shiny constant.     </td>
  </tr>
</table>
<a class="anchor" name="a74" doxytag="mr::Trowbridge_Reitz" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> miScalar Trowbridge_Reitz </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>NdH</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const miScalar&nbsp;</td>
          <td class="mdname" nowrap> <em>k2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Given the dot product of N.H, and a scalar value, calculate the Trowbridge-Reitz specular spread. Defined by this equation:<p>
D = ( (k2^2) / ((N.H)^2*(k2^2-1)+1) )^2;<p>
where k2 is the shiny constant     </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="a8" doxytag="mr::error" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmr_1_1errorstream.html">errorstream</a>* <a class="el" href="namespacemr.html#a8">mr::error</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="mr::fatal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmr_1_1fatalstream.html">fatalstream</a>* <a class="el" href="namespacemr.html#a9">mr::fatal</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="mr::info" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmr_1_1infostream.html">infostream</a>* <a class="el" href="namespacemr.html#a6">mr::info</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="mr::kNoInit" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const char* const <a class="el" href="namespacemr.html#a1">mr::kNoInit</a> = ""<code> [static]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="mr::kNotCached" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const miScalar <a class="el" href="namespacemr.html#a3">mr::kNotCached</a> = -255.0f<code> [static]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="mr::progress" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmr_1_1progressstream.html">progressstream</a>* <a class="el" href="namespacemr.html#a10">mr::progress</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="mr::streamMutex" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MR_LIB_EXPORT <a class="el" href="structmr_1_1mutex.html">mutex</a>* <a class="el" href="namespacemr.html#a5">mr::streamMutex</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="mr::warning" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmr_1_1warningstream.html">warningstream</a>* <a class="el" href="namespacemr.html#a7">mr::warning</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sun Feb 22 18:29:26 2004 for mrClasses by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>

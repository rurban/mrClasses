<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mrClasses: mrDerivs.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>mrDerivs.h</h1><a href="mrDerivs_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">//</span>
00002 <span class="comment">//  Copyright (c) 2004, Gonzalo Garramuno</span>
00003 <span class="comment">//</span>
00004 <span class="comment">//  All rights reserved.</span>
00005 <span class="comment">//</span>
00006 <span class="comment">//  Redistribution and use in source and binary forms, with or without</span>
00007 <span class="comment">//  modification, are permitted provided that the following conditions are</span>
00008 <span class="comment">//  met:</span>
00009 <span class="comment">//  *       Redistributions of source code must retain the above copyright</span>
00010 <span class="comment">//  notice, this list of conditions and the following disclaimer.</span>
00011 <span class="comment">//  *       Redistributions in binary form must reproduce the above</span>
00012 <span class="comment">//  copyright notice, this list of conditions and the following disclaimer</span>
00013 <span class="comment">//  in the documentation and/or other materials provided with the</span>
00014 <span class="comment">//  distribution.</span>
00015 <span class="comment">//  *       Neither the name of Gonzalo Garramuno nor the names of</span>
00016 <span class="comment">//  its other contributors may be used to endorse or promote products derived</span>
00017 <span class="comment">//  from this software without specific prior written permission. </span>
00018 <span class="comment">//</span>
00019 <span class="comment">//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
00020 <span class="comment">//  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
00021 <span class="comment">//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
00022 <span class="comment">//  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
00023 <span class="comment">//  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
00024 <span class="comment">//  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
00025 <span class="comment">//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
00026 <span class="comment">//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
00027 <span class="comment">//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
00028 <span class="comment">//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
00029 <span class="comment">//  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00030 <span class="comment">//</span>
00031 
00032 <span class="comment">//</span>
00033 <span class="comment">// A simple set of routines that encapsulate obtaining the most common</span>
00034 <span class="comment">// type of derivatives.</span>
00035 <span class="comment">//</span>
00036 
00037 <span class="preprocessor">#ifndef mrDerivs_h</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define mrDerivs_h</span>
00039 <span class="preprocessor"></span>
00040 <span class="preprocessor">#include &lt;set&gt;</span>
00041 
00042 <span class="preprocessor">#ifndef mrVector_h</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="mrVector_8h.html">mrVector.h</a>"</span>
00044 <span class="preprocessor">#endif</span>
00045 <span class="preprocessor"></span>
00046 <span class="preprocessor">#ifndef mrStream_h</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="mrStream_8h.html">mrStream.h</a>"</span>
00048 <span class="preprocessor">#endif</span>
00049 <span class="preprocessor"></span>
00050 
00051 
00052 <a class="code" href="mrMacros_8h.html#a0">BEGIN_NAMESPACE</a>( mr )
00053 
00054 
00055 
00056 
00057 <span class="keyword">inline</span>
<a name="l00058"></a><a class="code" href="namespacemr.html#a24">00058</a> <span class="keywordtype">void</span> <a class="code" href="namespacemr.html#a24">get_normals</a>( <span class="keyword">const</span> miState* <span class="keyword">const</span> state, miVector N[3] )
00059 {
00060   <span class="comment">// And the normals...</span>
00061   miVector* n[3];
00062   mi_tri_vectors(const_cast&lt;miState*&gt;(state), <span class="charliteral">'n'</span>, 0, &amp;n[0], &amp;n[1], &amp;n[2]);
00063 
00064   <span class="comment">// Those normals come in object space, transform to internal...</span>
00065   mi_normal_from_object( const_cast&lt;miState*&gt;(state), &amp;<a class="code" href="mrRman__macros_8h.html#a4">N</a>[0], n[0] );
00066   mi_normal_from_object( const_cast&lt;miState*&gt;(state), &amp;<a class="code" href="mrRman__macros_8h.html#a4">N</a>[1], n[1] );
00067   mi_normal_from_object( const_cast&lt;miState*&gt;(state), &amp;<a class="code" href="mrRman__macros_8h.html#a4">N</a>[2], n[2] );
00068 
00069   mi_vector_normalize(&amp;<a class="code" href="mrRman__macros_8h.html#a4">N</a>[0]);
00070   mi_vector_normalize(&amp;<a class="code" href="mrRman__macros_8h.html#a4">N</a>[1]);
00071   mi_vector_normalize(&amp;<a class="code" href="mrRman__macros_8h.html#a4">N</a>[2]);
00072 }
00073 
00076 <span class="keyword">inline</span>
<a name="l00077"></a><a class="code" href="namespacemr.html#a25">00077</a> <span class="keywordtype">void</span> <a class="code" href="namespacemr.html#a25">get_vertices</a>( <span class="keyword">const</span> miState* <span class="keyword">const</span> state, miVector v[3] )
00078 {
00079    <span class="comment">//</span>
00080    <span class="comment">// First, obtain the points of the triangle</span>
00081    <span class="comment">//</span>
00082    miVector* p[3];
00083    mi_tri_vectors(const_cast&lt;miState*&gt;(state), <span class="charliteral">'p'</span>, 0,
00084                   &amp;p[0], &amp;p[1], &amp;p[2]);
00085 
00086    <span class="comment">// Those points come in object space, transform to internal...</span>
00087    mi_point_from_object( const_cast&lt;miState*&gt;(state), &amp;<a class="code" href="mrRman__macros_8h.html#a10">v</a>[0], p[0] );
00088    mi_point_from_object( const_cast&lt;miState*&gt;(state), &amp;<a class="code" href="mrRman__macros_8h.html#a10">v</a>[1], p[1] );
00089    mi_point_from_object( const_cast&lt;miState*&gt;(state), &amp;<a class="code" href="mrRman__macros_8h.html#a10">v</a>[2], p[2] );
00090 }
00091 
<a name="l00094"></a><a class="code" href="namespacemr.html#a26">00094</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacemr.html#a26">check_bary_bounds</a>( miScalar b[3] )
00095 {
00096    <span class="keywordtype">float</span> s = (1.0f - b[0] - b[1] - b[2])/3.0f;
00097    b[0] += s;
00098    b[1] += s;
00099 
00100    <span class="comment">/* now clip coordinates */</span>
00101    <span class="keywordflow">if</span> (b[0] &lt; 0.0f)
00102       b[0] = 0.0f;
00103    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b[0] &gt; 1.0f)
00104       b[0] = 1.0f;
00105    
00106    <span class="keywordflow">if</span> (b[1] &lt; 0.0f)
00107       b[1] = 0.0f;
00108    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b[1] + b[0] &gt; 1.0f)
00109       b[1] = 1.0f-b[0];
00110    
00111    <span class="comment">/* Finally, compute the dependent z */</span>
00112    b[2] = 1.0f - b[0] - b[1];
00113 }
00114 
00115 
00146 
00147 <span class="keyword">inline</span> miBoolean
<a name="l00148"></a><a class="code" href="namespacemr.html#a27">00148</a> <a class="code" href="namespacemr.html#a27">calculate_bary</a>(
00149                miScalar b[3],        <span class="comment">// Returned barycentric coords</span>
00150                <span class="keyword">const</span> <a class="code" href="structmr_1_1point__base.html">point</a>&amp; p,       <span class="comment">// Point to check </span>
00151                <span class="keyword">const</span> miVector v[3]   <span class="comment">// Vertices of triangle internal space</span>
00152                )
00153 {
00154    <span class="comment">// Calculate edge segments</span>
00155    <a class="code" href="structmr_1_1vec__base.html">vector</a> E12( <a class="code" href="mrRman__macros_8h.html#a10">v</a>[0] - <a class="code" href="mrRman__macros_8h.html#a10">v</a>[1] ), E13( <a class="code" href="mrRman__macros_8h.html#a10">v</a>[0] - <a class="code" href="mrRman__macros_8h.html#a10">v</a>[2] );
00156    <a class="code" href="structmr_1_1vec__base.html">vector</a> n = E12 ^ E13;
00157    miScalar areaTriangle = 1.0f / n.<a class="code" href="structmr_1_1vecnorm.html#a3">length</a>();
00158 
00159    n *= areaTriangle;  <span class="comment">//&lt;- NEEDED!!!  this is n.normalize()</span>
00160 
00161    <a class="code" href="structmr_1_1vec__base.html">vector</a> E1P( <a class="code" href="mrRman__macros_8h.html#a10">v</a>[0] - p );
00162    b[0] = (( E1P ^ E13 ) % n) * areaTriangle;
00163    b[1] = (( E12 ^ E1P ) % n) * areaTriangle;
00164    b[2] = 1.0f - ( b[0] + b[1] );
00165    
00166    <span class="keywordflow">if</span> ( (b[0] &lt; 0.0f) || (b[1] &lt; 0.0f) || (b[2] &lt; 0.0f) )
00167       <span class="keywordflow">return</span> miFALSE;
00168    <span class="keywordflow">return</span> miTRUE;
00169 }
00170 
00171 <span class="keyword">inline</span> miBoolean
<a name="l00172"></a><a class="code" href="namespacemr.html#a28">00172</a> <a class="code" href="namespacemr.html#a27">calculate_bary</a>(
00173                miScalar bary[3], <span class="comment">// Returned barycentric coords</span>
00174                <span class="keyword">const</span> miState* <span class="keyword">const</span> state,
00175                <span class="keyword">const</span> <a class="code" href="structmr_1_1point__base.html">point</a>&amp; p   <span class="comment">// Point to check </span>
00176                )
00177 {
00178    miVector <a class="code" href="mrRman__macros_8h.html#a10">v</a>[3];
00179    <a class="code" href="namespacemr.html#a25">get_vertices</a>( state, <a class="code" href="mrRman__macros_8h.html#a10">v</a> );
00180    <span class="keywordflow">return</span> <a class="code" href="namespacemr.html#a27">calculate_bary</a>( bary, p, <a class="code" href="mrRman__macros_8h.html#a10">v</a> );
00181 }
00182 
00184 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00185"></a><a class="code" href="namespacemr.html#a29">00185</a> <a class="code" href="namespacemr.html#a29">calculate_bary2</a>(
00186                 miScalar bx[3],  <span class="comment">// Returned barycentric coords for pt1</span>
00187                 miScalar by[3],  <span class="comment">// Returned barycentric coords for pt2</span>
00188                 <span class="keyword">const</span> miState* <span class="keyword">const</span> state,
00189                 <span class="keyword">const</span> <a class="code" href="structmr_1_1point__base.html">point</a>&amp; px,  <span class="comment">// Point1</span>
00190                 <span class="keyword">const</span> <a class="code" href="structmr_1_1point__base.html">point</a>&amp; py   <span class="comment">// Point2</span>
00191                )
00192 {
00193    miVector <a class="code" href="mrRman__macros_8h.html#a10">v</a>[3];
00194    <a class="code" href="namespacemr.html#a25">get_vertices</a>( state, <a class="code" href="mrRman__macros_8h.html#a10">v</a> );
00195    <span class="keywordflow">if</span> (! <a class="code" href="namespacemr.html#a27">calculate_bary</a>( bx, px, <a class="code" href="mrRman__macros_8h.html#a10">v</a> ) )
00196       <a class="code" href="namespacemr.html#a26">check_bary_bounds</a>(bx);
00197    
00198    <span class="keywordflow">if</span> (! <a class="code" href="namespacemr.html#a27">calculate_bary</a>( by, py, <a class="code" href="mrRman__macros_8h.html#a10">v</a> ) )
00199       <a class="code" href="namespacemr.html#a26">check_bary_bounds</a>(by);
00200 }
00201 
00202 <span class="comment">//</span>
00207 <span class="comment"></span><span class="comment">//</span>
<a name="l00208"></a><a class="code" href="namespacemr.html#a30">00208</a> <span class="keyword">inline</span> miScalar <a class="code" href="namespacemr.html#a30">area</a>( <span class="keyword">const</span> miState* <span class="keyword">const</span> state )
00209 {
00210    <a class="code" href="structmr_1_1vec__base.html">vector</a> Rx( 1, 0, 0 ), Ry( 0, 1, 0 );
00211    mi_raster_unit( const_cast&lt; miState* &gt;( state ), &amp;Rx, &amp;Ry );
00212    Rx ^= Ry;
00213    <span class="keywordflow">return</span> Rx.<a class="code" href="structmr_1_1vecnorm.html#a3">length</a>();
00214 }
00215 
<a name="l00217"></a><a class="code" href="namespacemr.html#a31">00217</a> <span class="keyword">inline</span> miScalar <a class="code" href="namespacemr.html#a31">areaSquared</a>( <span class="keyword">const</span> miState* <span class="keyword">const</span> state )
00218 {
00219    <a class="code" href="structmr_1_1vec__base.html">vector</a> Rx( 1, 0, 0 ), Ry( 0, 1, 0 );
00220    mi_raster_unit( const_cast&lt; miState* &gt;( state ), &amp;Rx, &amp;Ry );
00221    Rx ^= Ry;
00222    <span class="keywordflow">return</span> Rx.<a class="code" href="structmr_1_1vecnorm.html#a2">lengthSquared</a>();
00223 }
00224 
00225 
<a name="l00227"></a><a class="code" href="namespacemr.html#a32">00227</a> <span class="keyword">inline</span> miScalar <a class="code" href="namespacemr.html#a30">area</a>( <span class="keyword">const</span> miState* <span class="keyword">const</span> state,
00228                       <span class="keyword">const</span> miVector&amp; P )
00229 {
00230    <a class="code" href="structmr_1_1vec__base.html">vector</a> Rx( 1, 0, 0 ), Ry( 0, 1, 0 );
00231    miState* <span class="keyword">const</span> s = const_cast&lt;miState*&gt;(state);
00232    <a class="code" href="structmr_1_1point__base.html">point</a> tmp( state-&gt;point );  s-&gt;point = <a class="code" href="mrRman__macros_8h.html#a3">P</a>;
00233    mi_raster_unit( const_cast&lt; miState* &gt;( state ), &amp;Rx, &amp;Ry );
00234    s-&gt;point = tmp;
00235    Rx ^= Ry;
00236    <span class="keywordflow">return</span> Rx.<a class="code" href="structmr_1_1vecnorm.html#a3">length</a>();
00237 }
00238 
00239 
00240 
<a name="l00245"></a><a class="code" href="namespacemr.html#a33">00245</a> <span class="keyword">inline</span> miScalar <a class="code" href="namespacemr.html#a33">areatriangle</a>( <span class="keyword">const</span> miState* <span class="keyword">const</span> state )
00246 {
00247    miVector p[3];
00248    <a class="code" href="namespacemr.html#a25">get_vertices</a>( state, p );
00249    <a class="code" href="structmr_1_1vec__base.html">vector</a> E12( p[0] - p[1] ), E13( p[0] - p[2] );
00250    <a class="code" href="structmr_1_1vec__base.html">vector</a> n( E12 ^ E13 );
00251    <span class="keywordflow">return</span> n.<a class="code" href="structmr_1_1vecnorm.html#a3">length</a>();
00252 }
00253 
<a name="l00255"></a><a class="code" href="namespacemr.html#a34">00255</a> <span class="keyword">inline</span> miScalar <a class="code" href="namespacemr.html#a34">areatriangleSquared</a>( <span class="keyword">const</span> miState* <span class="keyword">const</span> state )
00256 {
00257    miVector p[3];
00258    <a class="code" href="namespacemr.html#a25">get_vertices</a>( state, p );
00259    <a class="code" href="structmr_1_1vec__base.html">vector</a> E12( p[0] - p[1] ), E13( p[0] - p[2] );
00260    <a class="code" href="structmr_1_1vec__base.html">vector</a> n( E12 ^ E13 );
00261    <span class="keywordflow">return</span> n.<a class="code" href="structmr_1_1vecnorm.html#a2">lengthSquared</a>();
00262 }
00263 
<a name="l00266"></a><a class="code" href="namespacemr.html#a35">00266</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacemr.html#a35">get_sides</a>( <span class="keyword">const</span> miState* <span class="keyword">const</span> state, <span class="keywordtype">int</span>&amp; w, <span class="keywordtype">int</span>&amp; h )
00267 {
00268    miVector* p[3];
00269    mi_tri_vectors( const_cast&lt;miState*&gt;( state ), <span class="charliteral">'p'</span>, 0,
00270                    &amp;p[0], &amp;p[1], &amp;p[2] );
00271 
00272    miScalar e0,e1,e2;
00273    
00274    <a class="code" href="structmr_1_1vec__base.html">vector</a> <a class="code" href="mrRman__macros_8h.html#a2">E</a>( *p[1] - *p[0] );
00275    e0 = <a class="code" href="mrRman__macros_8h.html#a2">E</a>.length();
00276 
00277    <a class="code" href="mrRman__macros_8h.html#a2">E</a> = *p[2] - *p[1];
00278    e1 = <a class="code" href="mrRman__macros_8h.html#a2">E</a>.length();
00279    
00280    <a class="code" href="mrRman__macros_8h.html#a2">E</a> = *p[0] - *p[2];
00281    e2 = <a class="code" href="mrRman__macros_8h.html#a2">E</a>.length();
00282    
00283    w = 1; h = 2;
00284    <span class="keywordflow">if</span> ( e1 &gt; e0 &amp;&amp; e1 &gt; e2 )       w = 0;
00285    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( e2 &gt; e0 &amp;&amp; e2 &gt; e1 )  h = 0;
00286 }
00287 
00288 
00292 <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;
<a name="l00293"></a><a class="code" href="namespacemr.html#a36">00293</a> <span class="keyword">inline</span> miBoolean <a class="code" href="namespacemr.html#a36">DuDv_Impl</a>( T&amp; Du, T&amp; Dv,
00294                             <span class="keyword">const</span> miState* state,
00295                             <span class="keyword">const</span> miScalar u1,
00296                             <span class="keyword">const</span> miScalar u2,
00297                             <span class="keyword">const</span> miScalar v1,
00298                             <span class="keyword">const</span> miScalar v2,
00299                             <span class="keyword">const</span> T data[3],
00300                             <span class="keyword">const</span> <span class="keywordtype">int</span> idx = 0   <span class="comment">// tex_list[] considered as UV</span>
00301                             )
00302 {
00303 
00304    miScalar x1 = data[1].x - data[0].x;
00305    miScalar y1 = data[1].y - data[0].y;
00306    miScalar z1 = data[1].z - data[0].z;
00307    
00308    miScalar x2 = data[2].x - data[0].x;
00309    miScalar y2 = data[2].y - data[0].y;
00310    miScalar z2 = data[2].z - data[0].z;
00311 
00312    
00313    miScalar det = u1 * v2 - v1 * u2;   
00314    
00315    <span class="keywordflow">if</span> (det == 0.0f)
00316    {
00317       <span class="comment">// degenerate</span>
00318       Du.x = Dv.y = 1;
00319       Du.y = Du.z = Dv.x = Dv.z = 0;
00320       <span class="keywordflow">return</span> miFALSE;
00321    }
00322    
00323    miScalar invdet = 1.0f / det;
00324    Du.x = (x1 * v2 - v1 * x2) * invdet;
00325    Du.y = (y1 * v2 - v1 * y2) * invdet;
00326    Du.z = (z1 * v2 - v1 * z2) * invdet;
00327    Dv.x = (u1 * x2 - x1 * u2) * invdet;
00328    Dv.y = (u1 * y2 - y1 * u2) * invdet;
00329    Dv.z = (u1 * z2 - z1 * u2) * invdet;
00330    
00331    <span class="keywordflow">return</span> miTRUE;
00332 }
00333 
00334 
<a name="l00338"></a><a class="code" href="namespacemr.html#a37">00338</a> <span class="keyword">inline</span> miBoolean <a class="code" href="namespacemr.html#a36">DuDv_Impl</a>( <a class="code" href="structmr_1_1color.html">color</a>&amp; Du, <a class="code" href="structmr_1_1color.html">color</a>&amp; Dv,
00339                             <span class="keyword">const</span> miState* state,
00340                             <span class="keyword">const</span> miScalar u1,
00341                             <span class="keyword">const</span> miScalar u2,
00342                             <span class="keyword">const</span> miScalar v1,
00343                             <span class="keyword">const</span> miScalar v2,
00344                             <span class="keyword">const</span> <a class="code" href="structmr_1_1color.html">color</a> data[3],
00345                             <span class="keyword">const</span> <span class="keywordtype">int</span> idx   <span class="comment">// tex_list[] considered as UV</span>
00346                             )
00347 {
00348    
00349    miScalar x1 = data[1].r - data[0].r;
00350    miScalar y1 = data[1].g - data[0].g;
00351    miScalar z1 = data[1].b - data[0].b;
00352    miScalar a1 = data[1].a - data[0].a;
00353    
00354    miScalar x2 = data[2].r - data[0].r;
00355    miScalar y2 = data[2].g - data[0].g;
00356    miScalar z2 = data[2].b - data[0].b;
00357    miScalar a2 = data[2].a - data[0].a;
00358   
00359    miScalar det = u1 * v2 - v1 * u2;
00360    <span class="keywordflow">if</span> (det == 0.0f)
00361    {
00362       <span class="comment">// degenerate</span>
00363       Du.r = Dv.g = 1;
00364       Du.g = Du.b = Dv.r = Dv.b = Dv.a = Du.a = 0;
00365       <span class="keywordflow">return</span> miFALSE;
00366    }
00367    
00368    miScalar invdet = 1.0f / det;
00369    Du.r = (x1 * v2 - v1 * x2) * invdet;
00370    Du.g = (y1 * v2 - v1 * y2) * invdet;
00371    Du.b = (z1 * v2 - v1 * z2) * invdet;
00372    Du.a = (a1 * v2 - v1 * a2) * invdet;
00373    Dv.r = (u1 * x2 - x1 * u2) * invdet;
00374    Dv.g = (u1 * y2 - y1 * u2) * invdet;
00375    Dv.b = (u1 * z2 - z1 * u2) * invdet;
00376    Dv.a = (u1 * a2 - a1 * u2) * invdet;
00377    
00378    <span class="keywordflow">return</span> miTRUE;
00379 }
00380 
00381 
00382 
<a name="l00386"></a><a class="code" href="namespacemr.html#a38">00386</a> <span class="keyword">inline</span> miBoolean <a class="code" href="namespacemr.html#a36">DuDv_Impl</a>( <a class="code" href="structmr_1_1base_1_1vec2.html">vector2d</a>&amp; Du, <a class="code" href="structmr_1_1base_1_1vec2.html">vector2d</a>&amp; Dv,
00387                             <span class="keyword">const</span> miState* state,
00388                             <span class="keyword">const</span> miScalar u1,
00389                             <span class="keyword">const</span> miScalar u2,
00390                             <span class="keyword">const</span> miScalar v1,
00391                             <span class="keyword">const</span> miScalar v2,
00392                             <span class="keyword">const</span> <a class="code" href="structmr_1_1base_1_1vec2.html">vector2d</a> data[3],
00393                             <span class="keyword">const</span> <span class="keywordtype">int</span> idx   <span class="comment">// tex_list[] considered as UV</span>
00394                             )
00395 {  
00396    miScalar x1 = data[1].u - data[0].u;
00397    miScalar y1 = data[1].v - data[0].v;
00398    
00399    miScalar x2 = data[2].u - data[0].u;
00400    miScalar y2 = data[2].v - data[0].v;
00401   
00402    miScalar det = u1 * v2 - v1 * u2;
00403    <span class="keywordflow">if</span> (det == 0.0f)
00404    {
00405       <span class="comment">// degenerate</span>
00406       Du.u = Dv.v = 1;
00407       Du.v = Dv.u = 0;
00408       <span class="keywordflow">return</span> miFALSE;
00409    }
00410 
00411    
00412    miScalar invdet = 1.0f / det;
00413    Du.u = (x1 * v2 - v1 * x2) * invdet;
00414    Du.v = (y1 * v2 - v1 * y2) * invdet;
00415    Dv.u = (u1 * x2 - x1 * u2) * invdet;
00416    Dv.v = (u1 * y2 - y1 * u2) * invdet;
00417    <span class="keywordflow">return</span> miTRUE;
00418 }
00419 
00420 
00421 
00422 
00423 
<a name="l00427"></a><a class="code" href="namespacemr.html#a39">00427</a> <span class="keyword">inline</span> miBoolean <a class="code" href="namespacemr.html#a36">DuDv_Impl</a>( miScalar&amp; Du, miScalar&amp; Dv,
00428                             <span class="keyword">const</span> miState* state,
00429                             <span class="keyword">const</span> miScalar u1,
00430                             <span class="keyword">const</span> miScalar u2,
00431                             <span class="keyword">const</span> miScalar v1,
00432                             <span class="keyword">const</span> miScalar v2,
00433                             <span class="keyword">const</span> miScalar data[3],
00434                             <span class="keyword">const</span> <span class="keywordtype">int</span> idx    <span class="comment">// tex_list[] considered as UV</span>
00435                             )
00436 {
00437    
00438   miScalar x1 = data[1] - data[0];
00439   miScalar x2 = data[2] - data[0];
00440   
00441   miScalar det = u1 * v2 - v1 * u2;
00442   <span class="keywordflow">if</span> (det == 0.0f)
00443   {
00444      <span class="comment">// degenerate</span>
00445      Du = Dv = 0;
00446      <span class="keywordflow">return</span> miFALSE;
00447   }
00448    
00449   miScalar invdet = 1.0f / det;
00450   Du = (x1 * v2 - v1 * x2) * invdet;
00451   Dv = (u1 * x2 - x1 * u2) * invdet;
00452 
00453   <span class="keywordflow">return</span> miTRUE;
00454 }
00455 
00456 
00458 <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;
<a name="l00459"></a><a class="code" href="namespacemr.html#a40">00459</a> <span class="keyword">inline</span> miBoolean <a class="code" href="namespacemr.html#a36">DuDv_Impl</a>( T&amp; Du, T&amp; Dv,
00460                             <span class="keyword">const</span> miState* state,
00461                             <span class="keyword">const</span> miScalar bx[3],
00462                             <span class="keyword">const</span> miScalar by[3],
00463                             <span class="keyword">const</span> T data[3],
00464                             <span class="keyword">const</span> <span class="keywordtype">int</span> idx = 0   <span class="comment">// tex_list[] considered as UV</span>
00465                             )
00466 {
00467    <span class="keywordtype">int</span> num;
00468    mi_query( miQ_NUM_TEXTURES, const_cast&lt;miState*&gt;(state), miNULLTAG, &amp;num );
00469    <span class="keywordflow">if</span> ( idx &gt;= num )
00470    {
00471       mi_error(<span class="stringliteral">"DuDv:  idx( %d ) &gt;= num textures in object (%d)"</span>,
00472                idx, num);
00473       <span class="keywordflow">return</span> miFALSE;
00474    }
00475    
00476    miVector* t[3];
00477    mi_tri_vectors(const_cast&lt; miState* &gt;(state), <span class="charliteral">'t'</span>, idx,
00478                   &amp;t[0], &amp;t[1], &amp;t[2]);
00479    
00480    miVector st0 = ( *t[0] * state-&gt;bary[0] +
00481                     *t[1] * state-&gt;bary[1] +
00482                     *t[2] * state-&gt;bary[2] );
00483    miVector st1 = bx[0] * *t[0] + bx[1] * *t[1] + bx[2] * *t[2];
00484    miVector st2 = by[0] * *t[0] + by[1] * *t[1] + by[2] * *t[2];
00485    
00486    miScalar u1 = st1.x - st0.x;
00487    miScalar u2 = st2.x - st0.x;
00488    miScalar v1 = st1.y - st0.y;
00489    miScalar v2 = st2.y - st0.y;
00490    
00491    <span class="keywordflow">return</span> <a class="code" href="namespacemr.html#a36">DuDv_Impl</a>( Du, Dv, state, u1, u2, v1, v2, data, idx );  
00492 }
00493 
00494 
00496 <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;
<a name="l00497"></a><a class="code" href="namespacemr.html#a41">00497</a> <span class="keyword">inline</span> miBoolean <a class="code" href="namespacemr.html#a36">DuDv_Impl</a>( T&amp; Du, T&amp; Dv,
00498                             miScalar&amp; du, miScalar&amp; dv,
00499                             <span class="keyword">const</span> miState* state,
00500                             <span class="keyword">const</span> miScalar bx[3],
00501                             <span class="keyword">const</span> miScalar by[3],
00502                             <span class="keyword">const</span> T data[3],
00503                             <span class="keyword">const</span> <span class="keywordtype">int</span> idx = 0   <span class="comment">// tex_list[] considered as UV</span>
00504                             )
00505 {
00506    <span class="keywordtype">int</span> num;
00507    mi_query( miQ_NUM_TEXTURES, const_cast&lt;miState*&gt;(state), miNULLTAG, &amp;num );
00508    <span class="keywordflow">if</span> ( idx &gt;= num )
00509    {
00510       mi_error(<span class="stringliteral">"DuDv:  idx( %d ) &gt;= num textures in object (%d)"</span>,
00511                idx, num);
00512       <span class="keywordflow">return</span> miFALSE;
00513    }
00514    
00515    miVector* t[3];
00516    mi_tri_vectors(const_cast&lt; miState* &gt;(state), <span class="charliteral">'t'</span>, idx,
00517                   &amp;t[0], &amp;t[1], &amp;t[2]);
00518    
00519    miVector st0 = ( *t[0] * state-&gt;bary[0] +
00520                     *t[1] * state-&gt;bary[1] +
00521                     *t[2] * state-&gt;bary[2] );
00522    miVector st1 = bx[0] * *t[0] + bx[1] * *t[1] + bx[2] * *t[2];
00523    miVector st2 = by[0] * *t[0] + by[1] * *t[1] + by[2] * *t[2];
00524    
00525    miScalar u1 = st1.x - st0.x;
00526    miScalar u2 = st2.x - st0.x;
00527    miScalar v1 = st1.y - st0.y;
00528    miScalar v2 = st2.y - st0.y;
00529 
00530    miScalar mx,mn;
00531    <a class="code" href="namespacemr.html#a59">minmax</a>( mn, mx, t[0]-&gt;x, t[1]-&gt;x, t[2]-&gt;x);
00532    du = mx - mn;
00533    <a class="code" href="namespacemr.html#a59">minmax</a>( mn, mx, t[0]-&gt;y, t[1]-&gt;y, t[2]-&gt;y);
00534    dv = mx - mn;
00535    
00536    <span class="keywordflow">return</span> <a class="code" href="namespacemr.html#a36">DuDv_Impl</a>( Du, Dv, state, u1, u2, v1, v2, data, idx );
00537   
00538 }
00539 
00540 
00556 <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;
<a name="l00557"></a><a class="code" href="namespacemr.html#a42">00557</a> <span class="keyword">inline</span> miBoolean <a class="code" href="namespacemr.html#a42">DuDv</a>( T&amp; Du, T&amp; Dv,
00558                        miScalar&amp; du, miScalar&amp; dv,
00559                        <span class="keyword">const</span> miState* state,
00560                        <span class="keyword">const</span> <a class="code" href="structmr_1_1point__base.html">point</a>&amp; Px,
00561                        <span class="keyword">const</span> <a class="code" href="structmr_1_1point__base.html">point</a>&amp; Py,
00562                        <span class="keyword">const</span> T data[3],
00563                        <span class="keyword">const</span> <span class="keywordtype">int</span> idx = 0   <span class="comment">// tex_list[] considered as UV</span>
00564                        )
00565 {
00566    miScalar bx[3], by[3];
00567    <a class="code" href="namespacemr.html#a29">calculate_bary2</a>( bx, by, state, Px, Py );
00568    <span class="keywordflow">return</span> <a class="code" href="namespacemr.html#a36">DuDv_Impl</a>( Du, Dv, du, dv, state, bx, by, data, idx );  
00569 }
00570 
00586 <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;
<a name="l00587"></a><a class="code" href="namespacemr.html#a43">00587</a> <span class="keyword">inline</span> miBoolean <a class="code" href="namespacemr.html#a42">DuDv</a>( T&amp; Du, T&amp; Dv,
00588                        miScalar&amp; du, miScalar&amp; dv,
00589                        <span class="keyword">const</span> miState* state,
00590                        <span class="keyword">const</span> T tri_data[3],
00591                        <span class="keyword">const</span> <span class="keywordtype">int</span> idx = 0   <span class="comment">// tex_list[] considered as UV</span>
00592                        )
00593 {  
00594    <a class="code" href="structmr_1_1vec__base.html">vector</a> Rx( 0.1f, 0.0f, 0.0f );
00595    <a class="code" href="structmr_1_1vec__base.html">vector</a> Ry( 0.0f, 0.1f, 0.0f );
00596    mi_raster_unit( const_cast&lt; miState* &gt;( state ), &amp;Rx, &amp;Ry );
00597    <a class="code" href="structmr_1_1point__base.html">point</a> Px( state-&gt;point ); Px += Rx;
00598    <a class="code" href="structmr_1_1point__base.html">point</a> Py( state-&gt;point ); Py += Ry;
00599 
00600    miScalar bx[3], by[3];
00601    <a class="code" href="namespacemr.html#a29">calculate_bary2</a>( bx, by, state, Px, Py );
00602 
00603    T D[3];
00604    D[0] = ( tri_data[0] * state-&gt;bary[0] +
00605             tri_data[1] * state-&gt;bary[1] +
00606             tri_data[2] * state-&gt;bary[2] );
00607    D[1] = ( tri_data[0] * bx[0] +
00608             tri_data[1] * bx[1] +
00609             tri_data[2] * bx[2] );
00610    D[2] = ( tri_data[0] * by[0] +
00611             tri_data[1] * by[1] +
00612             tri_data[2] * by[2] );
00613 
00614    <span class="keywordflow">return</span> <a class="code" href="namespacemr.html#a36">DuDv_Impl</a>( Du, Dv, du, dv, state, bx, by, D, idx ); 
00615 }
00616 
00617 
00618 
00633 <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;
<a name="l00634"></a><a class="code" href="namespacemr.html#a44">00634</a> <span class="keyword">inline</span> miBoolean <a class="code" href="namespacemr.html#a42">DuDv</a>(
00635                       T&amp; Du, T&amp; Dv,
00636                       <span class="keyword">const</span> miState* state,
00637                       <span class="keyword">const</span> <a class="code" href="structmr_1_1vec__base.html">vector</a>&amp; Px, <span class="keyword">const</span> <a class="code" href="structmr_1_1vec__base.html">vector</a>&amp; Py,
00638                       <span class="keyword">const</span> T data[3],
00639                       <span class="keyword">const</span> <span class="keywordtype">int</span> idx = 0
00640                       )
00641 {
00642    <span class="keywordflow">return</span> <a class="code" href="namespacemr.html#a42">DuDv</a>( Du, Dv, state, Px, Py, data, idx );
00643 }
00644 
00645 
00646 
00661 <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;
<a name="l00662"></a><a class="code" href="namespacemr.html#a45">00662</a> <span class="keyword">inline</span> miBoolean  <a class="code" href="namespacemr.html#a42">DuDv</a>( T&amp; Du, T&amp; Dv,
00663                         <span class="keyword">const</span> miState* state,
00664                         <span class="keyword">const</span> T tri_data[3],
00665                         <span class="keyword">const</span> <span class="keywordtype">int</span> idx = 0   <span class="comment">// tex_list[] considered as UV</span>
00666                         )
00667 {
00668    <a class="code" href="structmr_1_1vec__base.html">vector</a> Rx( 0.1f, 0.0f, 0.0f );
00669    <a class="code" href="structmr_1_1vec__base.html">vector</a> Ry( 0.0f, 0.1f, 0.0f );
00670    mi_raster_unit( const_cast&lt; miState* &gt;( state ), &amp;Rx, &amp;Ry );
00671    <a class="code" href="structmr_1_1point__base.html">point</a> Px( state-&gt;point ); Px += Rx;
00672    <a class="code" href="structmr_1_1point__base.html">point</a> Py( state-&gt;point ); Py += Ry;
00673 
00674    miScalar bx[3], by[3];
00675    <a class="code" href="namespacemr.html#a29">calculate_bary2</a>( bx, by, state, Px, Py );
00676 
00677    T D[3];
00678    D[0] = ( tri_data[0] * state-&gt;bary[0] +
00679             tri_data[1] * state-&gt;bary[1] +
00680             tri_data[2] * state-&gt;bary[2] );
00681    D[1] = ( tri_data[0] * bx[0] +
00682             tri_data[1] * bx[1] +
00683             tri_data[2] * bx[2] );
00684    D[2] = ( tri_data[0] * by[0] +
00685             tri_data[1] * by[1] +
00686             tri_data[2] * by[2] );
00687 
00688    <span class="keywordflow">return</span> <a class="code" href="namespacemr.html#a36">DuDv_Impl</a>( Du, Dv, state, bx, by, D, idx );
00689 }
00690 
00691 
<a name="l00693"></a><a class="code" href="namespacemr.html#a46">00693</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacemr.html#a46">DsuDtv</a>(
00694                    <span class="keyword">const</span> miState* <span class="keyword">const</span> state,
00695                    miScalar&amp; DuS, miScalar&amp; DvS,
00696                    miScalar&amp; DuT, miScalar&amp; DvT,
00697                    <span class="keyword">const</span> <span class="keywordtype">int</span> STidx = 0, <span class="comment">// tex_list[] considered as ST</span>
00698                    <span class="keyword">const</span> <span class="keywordtype">int</span> UVidx = 0  <span class="comment">// tex_list[] considered as ST</span>
00699                    )
00700 {
00701    
00702    <span class="keywordtype">int</span> num;
00703    mi_query( miQ_NUM_TEXTURES, const_cast&lt;miState*&gt;( state ),
00704              miNULLTAG, &amp;num );
00705    <span class="keywordflow">if</span> ( STidx &gt;= num )
00706    {
00707       mi_error(<span class="stringliteral">"DsuDtv:  STidx( %d ) &gt;= num textures in object (%d)"</span>,
00708                STidx, num);
00709       DuS = DvS = DuT = DvT = 0.0f;
00710       <span class="keywordflow">return</span>;
00711    }
00712 
00713    miVector*  t[3];
00714    mi_tri_vectors(const_cast&lt; miState* &gt;(state), <span class="charliteral">'t'</span>, STidx,
00715                   &amp;t[0], &amp;t[1], &amp;t[2]);
00716 
00717    miScalar du, dv;
00718    <a class="code" href="structmr_1_1base_1_1vec2.html">vector2d</a> Du;
00719    <a class="code" href="structmr_1_1base_1_1vec2.html">vector2d</a> Dv;
00720    <a class="code" href="structmr_1_1base_1_1vec2.html">vector2d</a> st[3];
00721    st[0] = *( reinterpret_cast&lt;vector2d*&gt;(t[0]) );
00722    st[1] = *( reinterpret_cast&lt;vector2d*&gt;(t[1]) );
00723    st[2] = *( reinterpret_cast&lt;vector2d*&gt;(t[2]) );
00724    <a class="code" href="namespacemr.html#a42">DuDv</a>( Du, Dv, du, dv, state, st, UVidx );
00725 
00726    DuS = Du.u * du; DvS = Dv.u * dv;
00727    DuT = Du.v * du; DvT = Dv.v * dv;
00728 }
00729 
00730 
00731 
00732 
00733 
00739 
00740 
00743 <span class="keyword">static</span>
<a name="l00744"></a><a class="code" href="namespacemr.html#a47">00744</a> miBoolean <a class="code" href="namespacemr.html#a47">dPdst</a>(
00745                 miVector&amp; dPds, miVector&amp; dPdt,
00746                 <span class="keyword">const</span> miState* <span class="keyword">const</span> state, <span class="keyword">const</span> <span class="keywordtype">int</span> idx = 0
00747                 )
00748 {
00749 
00750   <span class="comment">//</span>
00751   <span class="comment">// First, obtain the texture coordinates of the the three</span>
00752   <span class="comment">// vertices of the triangle, according to user parameters </span>
00753   <span class="comment">// (projection type, etc).</span>
00754   <span class="comment">//</span>
00755   miVector* t[3];
00756   mi_tri_vectors(const_cast&lt; miState* &gt;(state), <span class="charliteral">'t'</span>, idx,
00757                  &amp;t[0], &amp;t[1], &amp;t[2]);
00758 
00759   miScalar u1 = t[1]-&gt;x - t[0]-&gt;x;
00760   miScalar u2 = t[2]-&gt;x - t[0]-&gt;x;
00761   miScalar v1 = t[1]-&gt;y - t[0]-&gt;y;
00762   miScalar v2 = t[2]-&gt;y - t[0]-&gt;y;
00763   
00764   miScalar det = u1 * v2 - v1 * u2;
00765   <span class="keywordflow">if</span> (det == 0.0f)
00766   {
00767      <span class="comment">// degenerate</span>
00768      dPds.x = dPdt.y = 1;
00769      dPds.y = dPds.z = dPdt.x = dPdt.z = 0;
00770      <span class="keywordflow">return</span> miFALSE;
00771   }
00772   
00773   <span class="comment">//</span>
00774   <span class="comment">// First, obtain the points of the triangle</span>
00775   <span class="comment">// </span>
00776   miVector <a class="code" href="mrRman__macros_8h.html#a10">v</a>[3];
00777   <a class="code" href="namespacemr.html#a25">get_vertices</a>( state, <a class="code" href="mrRman__macros_8h.html#a10">v</a> );
00778   
00779   miScalar x1 = <a class="code" href="mrRman__macros_8h.html#a10">v</a>[1].x - <a class="code" href="mrRman__macros_8h.html#a10">v</a>[0].x;
00780   miScalar x2 = <a class="code" href="mrRman__macros_8h.html#a10">v</a>[2].x - <a class="code" href="mrRman__macros_8h.html#a10">v</a>[0].x;
00781   miScalar y1 = <a class="code" href="mrRman__macros_8h.html#a10">v</a>[1].y - <a class="code" href="mrRman__macros_8h.html#a10">v</a>[0].y;
00782   miScalar y2 = <a class="code" href="mrRman__macros_8h.html#a10">v</a>[2].y - <a class="code" href="mrRman__macros_8h.html#a10">v</a>[0].y;
00783   miScalar z1 = <a class="code" href="mrRman__macros_8h.html#a10">v</a>[1].z - <a class="code" href="mrRman__macros_8h.html#a10">v</a>[0].z;
00784   miScalar z2 = <a class="code" href="mrRman__macros_8h.html#a10">v</a>[2].z - <a class="code" href="mrRman__macros_8h.html#a10">v</a>[0].z;
00785   
00786   miScalar invdet = 1.0f / det;
00787   dPds.x = (x1 * v2 - v1 * x2) * invdet;
00788   dPds.y = (y1 * v2 - v1 * y2) * invdet;
00789   dPds.z = (z1 * v2 - v1 * z2) * invdet;
00790   dPdt.x = (u1 * x2 - x1 * u2) * invdet;
00791   dPdt.y = (u1 * y2 - y1 * u2) * invdet;
00792   dPdt.z = (u1 * z2 - z1 * u2) * invdet;
00793 
00794   
00795   <span class="keywordflow">return</span> miTRUE;
00796 }
00797 
00798 
00799 
00802 <span class="keyword">static</span>
<a name="l00803"></a><a class="code" href="namespacemr.html#a48">00803</a> miBoolean <a class="code" href="namespacemr.html#a48">dNdst</a>( miVector&amp; dNds, miVector&amp; dNdt,
00804                  <span class="keyword">const</span> miState* <span class="keyword">const</span> state, <span class="keyword">const</span> <span class="keywordtype">int</span> idx = 0 )
00805 {
00806   <span class="comment">//</span>
00807   <span class="comment">// First, obtain the texture coordinates of the the three</span>
00808   <span class="comment">// vertices of the triangle, according to user parameters </span>
00809   <span class="comment">// (projection type, etc).</span>
00810   <span class="comment">//</span>
00811   miVector* t[3];
00812   mi_tri_vectors(const_cast&lt; miState* &gt;(state), <span class="charliteral">'t'</span>, idx, &amp;t[0], &amp;t[1], &amp;t[2]);
00813 
00814   
00815   miScalar u1 = t[1]-&gt;x - t[0]-&gt;x;
00816   miScalar u2 = t[2]-&gt;x - t[0]-&gt;x;
00817   miScalar v1 = t[1]-&gt;y - t[0]-&gt;y;
00818   miScalar v2 = t[2]-&gt;y - t[0]-&gt;y;
00819   
00820   miScalar det = u1 * v2 - v1 * u2;
00821   <span class="keywordflow">if</span> (det == 0.0f)
00822   {
00823      <span class="comment">// degenerate</span>
00824      dNds.x = dNdt.y = 1;
00825      dNds.y = dNds.z = dNdt.x = dNdt.z = 0;
00826      <span class="keywordflow">return</span> miFALSE;
00827   }
00828 
00829   <span class="comment">//</span>
00830   <span class="comment">// Do dNds, dNdt</span>
00831   <span class="comment">//</span>
00832   miVector <a class="code" href="mrRman__macros_8h.html#a4">N</a>[3];
00833   <a class="code" href="namespacemr.html#a24">get_normals</a>( state, <a class="code" href="mrRman__macros_8h.html#a4">N</a> );
00834   
00835   miScalar x1 = <a class="code" href="mrRman__macros_8h.html#a4">N</a>[1].x - <a class="code" href="mrRman__macros_8h.html#a4">N</a>[0].x;
00836   miScalar x2 = <a class="code" href="mrRman__macros_8h.html#a4">N</a>[2].x - <a class="code" href="mrRman__macros_8h.html#a4">N</a>[0].x;
00837   miScalar y1 = <a class="code" href="mrRman__macros_8h.html#a4">N</a>[1].y - <a class="code" href="mrRman__macros_8h.html#a4">N</a>[0].y;
00838   miScalar y2 = <a class="code" href="mrRman__macros_8h.html#a4">N</a>[2].y - <a class="code" href="mrRman__macros_8h.html#a4">N</a>[0].y;
00839   miScalar z1 = <a class="code" href="mrRman__macros_8h.html#a4">N</a>[1].z - <a class="code" href="mrRman__macros_8h.html#a4">N</a>[0].z;
00840   miScalar z2 = <a class="code" href="mrRman__macros_8h.html#a4">N</a>[2].z - <a class="code" href="mrRman__macros_8h.html#a4">N</a>[0].z;
00841   
00842   miScalar invdet = 1.0f / det;
00843   dNds.x = (x1 * v2 - v1 * x2) * invdet;
00844   dNds.y = (y1 * v2 - v1 * y2) * invdet;
00845   dNds.z = (z1 * v2 - v1 * z2) * invdet;
00846   dNdt.x = (u1 * x2 - x1 * u2) * invdet;
00847   dNdt.y = (u1 * y2 - y1 * u2) * invdet;
00848   dNdt.z = (u1 * z2 - z1 * u2) * invdet;
00849 
00850   <span class="keywordflow">return</span> miTRUE;
00851 }
00852 
00853 
00856 <span class="keyword">static</span>
<a name="l00857"></a><a class="code" href="namespacemr.html#a49">00857</a> miBoolean <a class="code" href="namespacemr.html#a49">dPNdst</a>( 
00858                   miVector&amp; dPds, miVector&amp; dPdt,
00859                   miVector&amp; dNds, miVector&amp; dNdt,
00860                   <span class="keyword">const</span> miState* <span class="keyword">const</span> state, <span class="keyword">const</span> <span class="keywordtype">int</span> idx = 0
00861                   )
00862 {
00863   <span class="comment">//</span>
00864   <span class="comment">// First, obtain the texture coordinates of the the three</span>
00865   <span class="comment">// vertices of the triangle, according to user parameters </span>
00866   <span class="comment">// (projection type, etc).</span>
00867   <span class="comment">//</span>
00868   miVector* t[3];
00869   mi_tri_vectors(const_cast&lt; miState* &gt;(state), <span class="charliteral">'t'</span>, idx, &amp;t[0], &amp;t[1], &amp;t[2]);
00870 
00871   
00872   miScalar u1 = t[1]-&gt;x - t[0]-&gt;x;
00873   miScalar u2 = t[2]-&gt;x - t[0]-&gt;x;
00874   miScalar v1 = t[1]-&gt;y - t[0]-&gt;y;
00875   miScalar v2 = t[2]-&gt;y - t[0]-&gt;y;
00876   
00877   miScalar det = u1 * v2 - v1 * u2;
00878   <span class="keywordflow">if</span> (det == 0.0f)
00879   {
00880      <span class="comment">// degenerate</span>
00881      dNds.x = dNdt.y = 1;
00882      dNds.y = dNds.z = dNdt.x = dNdt.z = 0;
00883      dPds.x = dPdt.y = 1;
00884      dPds.y = dPds.z = dPdt.x = dPdt.z = 0;
00885      <span class="keywordflow">return</span> miFALSE;
00886   }
00887 
00888   <span class="comment">//</span>
00889   <span class="comment">// Do dNds, dNdt</span>
00890   <span class="comment">//</span>
00891   miVector <a class="code" href="mrRman__macros_8h.html#a4">N</a>[3];
00892   <a class="code" href="namespacemr.html#a24">get_normals</a>( state, <a class="code" href="mrRman__macros_8h.html#a4">N</a> );
00893   
00894   miScalar x1 = <a class="code" href="mrRman__macros_8h.html#a4">N</a>[1].x - <a class="code" href="mrRman__macros_8h.html#a4">N</a>[0].x;
00895   miScalar x2 = <a class="code" href="mrRman__macros_8h.html#a4">N</a>[2].x - <a class="code" href="mrRman__macros_8h.html#a4">N</a>[0].x;
00896   miScalar y1 = <a class="code" href="mrRman__macros_8h.html#a4">N</a>[1].y - <a class="code" href="mrRman__macros_8h.html#a4">N</a>[0].y;
00897   miScalar y2 = <a class="code" href="mrRman__macros_8h.html#a4">N</a>[2].y - <a class="code" href="mrRman__macros_8h.html#a4">N</a>[0].y;
00898   miScalar z1 = <a class="code" href="mrRman__macros_8h.html#a4">N</a>[1].z - <a class="code" href="mrRman__macros_8h.html#a4">N</a>[0].z;
00899   miScalar z2 = <a class="code" href="mrRman__macros_8h.html#a4">N</a>[2].z - <a class="code" href="mrRman__macros_8h.html#a4">N</a>[0].z;
00900   
00901   miScalar invdet = 1.0f / det;
00902   dNds.x = (x1 * v2 - v1 * x2) * invdet;
00903   dNds.y = (y1 * v2 - v1 * y2) * invdet;
00904   dNds.z = (z1 * v2 - v1 * z2) * invdet;
00905   dNdt.x = (u1 * x2 - x1 * u2) * invdet;
00906   dNdt.y = (u1 * y2 - y1 * u2) * invdet;
00907   dNdt.z = (u1 * z2 - z1 * u2) * invdet;
00908      
00909   <span class="comment">//</span>
00910   <span class="comment">// And dPds, dPdt</span>
00911   <span class="comment">// </span>
00912   miVector <a class="code" href="mrRman__macros_8h.html#a10">v</a>[3];
00913   <a class="code" href="namespacemr.html#a25">get_vertices</a>( state, <a class="code" href="mrRman__macros_8h.html#a10">v</a> );
00914   
00915   x1 = <a class="code" href="mrRman__macros_8h.html#a10">v</a>[1].x - <a class="code" href="mrRman__macros_8h.html#a10">v</a>[0].x;
00916   x2 = <a class="code" href="mrRman__macros_8h.html#a10">v</a>[2].x - <a class="code" href="mrRman__macros_8h.html#a10">v</a>[0].x;
00917   y1 = <a class="code" href="mrRman__macros_8h.html#a10">v</a>[1].y - <a class="code" href="mrRman__macros_8h.html#a10">v</a>[0].y;
00918   y2 = <a class="code" href="mrRman__macros_8h.html#a10">v</a>[2].y - <a class="code" href="mrRman__macros_8h.html#a10">v</a>[0].y;
00919   z1 = <a class="code" href="mrRman__macros_8h.html#a10">v</a>[1].z - <a class="code" href="mrRman__macros_8h.html#a10">v</a>[0].z;
00920   z2 = <a class="code" href="mrRman__macros_8h.html#a10">v</a>[2].z - <a class="code" href="mrRman__macros_8h.html#a10">v</a>[0].z;
00921   
00922   dPds.x = (x1 * v2 - v1 * x2) * invdet;
00923   dPds.y = (y1 * v2 - v1 * y2) * invdet;
00924   dPds.z = (z1 * v2 - v1 * z2) * invdet;
00925   dPdt.x = (u1 * x2 - x1 * u2) * invdet;
00926   dPdt.y = (u1 * y2 - y1 * u2) * invdet;
00927   dPdt.z = (u1 * z2 - z1 * u2) * invdet;
00928 
00929   <span class="keywordflow">return</span> miTRUE;
00930 }
00931 
00932 
00935 <span class="keyword">static</span>
<a name="l00936"></a><a class="code" href="namespacemr.html#a50">00936</a> miBoolean <a class="code" href="namespacemr.html#a50">dPduv</a>(
00937                 miVector&amp; dPdu, miVector&amp; dPdv,
00938                 <span class="keyword">const</span> miState* <span class="keyword">const</span> state
00939                 )
00940 {
00941    <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a> = state-&gt;derivs[0];
00942    <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a> = state-&gt;derivs[1];
00943    
00944    miBoolean hasDerivs;
00945    mi_query( miQ_GEO_HAS_DERIVS, const_cast&lt;miState*&gt;(state),
00946              miNULLTAG, &amp;hasDerivs);
00947    
00948    <span class="keywordflow">if</span> ( ! hasDerivs )
00949    {
00950       <span class="keyword">static</span> std::set&lt;miTag&gt; inst;
00951       <span class="keywordflow">if</span> ( inst.find(state-&gt;instance) == inst.end() )
00952       {
00953          <a class="code" href="mrStream_8h.html#a1">mr_warn</a>(<span class="stringliteral">"Object "</span> &lt;&lt; tag2name(state-&gt;instance) &lt;&lt;
00954                  <span class="stringliteral">" does not have dPdu, dPdv derivatives."</span>);
00955          inst.insert( state-&gt;instance );
00956       }
00957       <span class="keywordflow">return</span> miFALSE;
00958    }
00959    
00960    <span class="keywordflow">return</span> miTRUE;
00961 }
00962 
00963 
00965 <span class="keyword">static</span>
<a name="l00966"></a><a class="code" href="namespacemr.html#a51">00966</a> miBoolean <a class="code" href="namespacemr.html#a51">BumpUV</a>( 
00967                  miVector&amp; dPdu, miVector&amp; dPdv,
00968                  <span class="keyword">const</span> miState* <span class="keyword">const</span> state,
00969                  <span class="keyword">const</span> <span class="keywordtype">int</span> idx = 0
00970                 )
00971 {
00972    <span class="comment">// Check to see if bump derivatives available.  If so, use that instead, as</span>
00973    <span class="comment">// they are more accurate.</span>
00974    <span class="keywordtype">int</span> num;
00975    mi_query( miQ_NUM_BUMPS, const_cast&lt;miState*&gt;(state), miNULLTAG, &amp;num);
00976    
00977    <span class="keywordflow">if</span> ( num &gt; idx )
00978    {
00979       <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a> = state-&gt;bump_x_list[idx];
00980       <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a> = state-&gt;bump_y_list[idx];
00981       <span class="keywordflow">return</span> miTRUE;
00982    }
00983 
00984    <span class="keywordflow">if</span> ( ! <a class="code" href="namespacemr.html#a47">dPdst</a>( <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>, <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>, state, idx ) ) <span class="keywordflow">return</span> miFALSE;
00985    
00986    <span class="comment">// Make sure tangents form an orthogonal basis with normal.</span>
00987    <span class="comment">// See Ken Turkowski '93</span>
00988    <span class="comment">// http://www.worldserver.com/turk/computergraphics/DifferentialMappings.pdf</span>
00989    miVector C;
00990    mi_vector_prod(&amp;C, &amp;state-&gt;normal, &amp;<a class="code" href="mrRman__macros_8h.html#a7">dPdu</a> );
00991    miScalar t2 = <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.x * <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.x + <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.y * <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.y + <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.z * <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.z;
00992    miScalar NxT2 = C.x * C.x + C.y * C.y + C.z * C.z;
00993    mi_vector_prod(&amp;<a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>, &amp;C, &amp;state-&gt;normal);
00994    <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a> *= ( t2 / NxT2 );
00995    
00996    mi_vector_prod(&amp;C, &amp;state-&gt;normal, &amp;<a class="code" href="mrRman__macros_8h.html#a8">dPdv</a> );
00997    t2 = <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.x * <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.x + <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.y * <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.y + <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.z * <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.z;
00998    NxT2 = C.x * C.x + C.y * C.y + C.z * C.z;
00999    mi_vector_prod(&amp;<a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>, &amp;C, &amp;state-&gt;normal);
01000    <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a> *= ( t2 / NxT2 );
01001 
01002    <span class="keywordflow">return</span> miTRUE;
01003 }
01004 
01005 
01007 <span class="keyword">static</span>
<a name="l01008"></a><a class="code" href="namespacemr.html#a52">01008</a> miBoolean <a class="code" href="namespacemr.html#a52">dPduv2</a>(
01009                  miVector&amp; dP2du2, miVector&amp; dP2dv2, miVector&amp; dP2dudv,
01010                  <span class="keyword">const</span> miState* <span class="keyword">const</span> state
01011                  )
01012 {
01013    dP2du2 = state-&gt;derivs[2];
01014    dP2dv2 = state-&gt;derivs[3];
01015    dP2dudv = state-&gt;derivs[4];
01016       
01017    miBoolean hasDerivs;
01018    mi_query( miQ_GEO_HAS_DERIVS2, const_cast&lt;miState*&gt;(state),
01019              miNULLTAG, &amp;hasDerivs);
01020    <span class="keywordflow">if</span> ( !hasDerivs )
01021    {
01022       <span class="keyword">static</span> std::set&lt;miTag&gt; inst;
01023       <span class="keywordflow">if</span> ( inst.find(state-&gt;instance) == inst.end() )
01024       {
01025          <a class="code" href="mrStream_8h.html#a1">mr_warn</a>(<span class="stringliteral">"Object "</span> &lt;&lt; tag2name(state-&gt;instance) &lt;&lt;
01026                  <span class="stringliteral">" does not have dP2du2, dP2dv2, dP2dudv derivatives."</span>);
01027          inst.insert( state-&gt;instance );
01028       }
01029       <span class="keywordflow">return</span> miFALSE;
01030    }
01031    
01032    <span class="keywordflow">return</span> miTRUE;
01033 }
01034 
01035 
01037 
01038 <span class="keyword">template</span>&lt; <span class="keyword">class</span> C, <span class="keyword">typename</span> T &gt;
<a name="l01039"></a><a class="code" href="structmr_1_1vec__base.html#a7">01039</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="structmr_1_1vec__base.html">vec_base&lt; C, T &gt;::fromTangent</a>( <span class="keyword">const</span> miState* <span class="keyword">const</span> state,
01040                                            <span class="keyword">const</span> <span class="keywordtype">int</span> idx )
01041 {
01042    <a class="code" href="structmr_1_1vec__base.html">vector</a> <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>( kNoInit ), <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>( kNoInit );
01043    <span class="keywordflow">if</span> ( ! dPdut( state, idx, <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>, <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a> ) ) <span class="keywordflow">return</span>;
01044    <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.normalize();
01045    <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.normalize();
01046    <a class="code" href="classmr_1_1matrix.html">matrix</a> m( <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.x, <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.y, <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.z,
01047              <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.x, <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.y, <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.z,
01048              state-&gt;normal.x, state-&gt;normal.y, state-&gt;normal.z
01049               );
01050    *<span class="keyword">this</span> *= m;
01051 }
01052 
01053 <span class="keyword">template</span>&lt; <span class="keyword">class</span> C, <span class="keyword">typename</span> T &gt;
<a name="l01054"></a><a class="code" href="structmr_1_1vec__base.html#a0">01054</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="structmr_1_1vec__base.html">vec_base&lt; C, T &gt;::toTangent</a>( <span class="keyword">const</span> miState* <span class="keyword">const</span> state,
01055                                          <span class="keyword">const</span> <span class="keywordtype">int</span> idx  )
01056 {
01057    <a class="code" href="structmr_1_1vec__base.html">vector</a> <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>( kNoInit ), <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>( kNoInit );
01058    <span class="keywordflow">if</span> ( ! <a class="code" href="namespacemr.html#a50">dPduv</a>( <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>, <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>, state ) ) <span class="keywordflow">return</span>;
01059    <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.normalize();
01060    <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.normalize();
01061    <a class="code" href="classmr_1_1matrix.html">matrix</a> m( <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.x, <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.y, <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.z,
01062              <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.x, <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.y, <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.z,
01063              state-&gt;normal.x, state-&gt;normal.y, state-&gt;normal.z
01064              );
01065    m.<a class="code" href="classmr_1_1matrix.html#z23_9">invert3x3</a>();
01066    *<span class="keyword">this</span> *= m;
01067 }
01068 
01069 <span class="keyword">template</span>&lt; <span class="keyword">class</span> C, <span class="keyword">typename</span> T &gt;
<a name="l01070"></a><a class="code" href="structmr_1_1normal__base.html#a7">01070</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="structmr_1_1normal__base.html">normal_base&lt; C, T &gt;::fromTangent</a>( <span class="keyword">const</span> miState* <span class="keyword">const</span> state,
01071                                               <span class="keyword">const</span> <span class="keywordtype">int</span> idx )
01072 {
01073    <a class="code" href="structmr_1_1vec__base.html">vector</a> <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>( kNoInit ), <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>( kNoInit );
01074    <span class="keywordflow">if</span> ( ! <a class="code" href="namespacemr.html#a50">dPduv</a>( <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>, <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>, state ) ) <span class="keywordflow">return</span>;
01075    <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.normalize();
01076    <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.normalize();
01077    <a class="code" href="classmr_1_1matrix.html">matrix</a> m( <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.x, <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.y, <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.z,
01078              <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.x, <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.y, <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.z,
01079              state-&gt;normal.x, state-&gt;normal.y, state-&gt;normal.z );
01080    *<span class="keyword">this</span> *= m;
01081 }
01082 
01083 <span class="keyword">template</span>&lt; <span class="keyword">class</span> C, <span class="keyword">typename</span> T &gt;
<a name="l01084"></a><a class="code" href="structmr_1_1normal__base.html#a0">01084</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="structmr_1_1normal__base.html">normal_base&lt; C, T &gt;::toTangent</a>( <span class="keyword">const</span> miState* <span class="keyword">const</span> state,
01085                                             <span class="keyword">const</span> <span class="keywordtype">int</span> idx  )
01086 {
01087    <a class="code" href="structmr_1_1vec__base.html">vector</a> <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>( kNoInit ), <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>( kNoInit );
01088    <span class="keywordflow">if</span> ( ! <a class="code" href="namespacemr.html#a50">dPduv</a>( <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>, <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>, state ) ) <span class="keywordflow">return</span>;
01089    <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.normalize();
01090    <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.normalize();
01091    <a class="code" href="classmr_1_1matrix.html">matrix</a> m( <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.x, <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.y, <a class="code" href="mrRman__macros_8h.html#a7">dPdu</a>.z,
01092              <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.x, <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.y, <a class="code" href="mrRman__macros_8h.html#a8">dPdv</a>.z,
01093              state-&gt;normal.x, state-&gt;normal.y, state-&gt;normal.z );
01094    m.<a class="code" href="classmr_1_1matrix.html#z23_9">invert3x3</a>();
01095    *<span class="keyword">this</span> *= m;
01096 }
01097 
01098 <a class="code" href="mrMacros_8h.html#a1">END_NAMESPACE</a>( mr )
01099 
01100 
01101 
01102 #endif <span class="comment">// mrDerivs_h</span>
01103 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Feb 22 18:29:23 2004 for mrClasses by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mrClasses: mrCache.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>mrCache.h</h1><a href="mrCache_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">//</span>
00002 <span class="comment">//  Copyright (c) 2004, Gonzalo Garramuno</span>
00003 <span class="comment">//</span>
00004 <span class="comment">//  All rights reserved.</span>
00005 <span class="comment">//</span>
00006 <span class="comment">//  Redistribution and use in source and binary forms, with or without</span>
00007 <span class="comment">//  modification, are permitted provided that the following conditions are</span>
00008 <span class="comment">//  met:</span>
00009 <span class="comment">//  *       Redistributions of source code must retain the above copyright</span>
00010 <span class="comment">//  notice, this list of conditions and the following disclaimer.</span>
00011 <span class="comment">//  *       Redistributions in binary form must reproduce the above</span>
00012 <span class="comment">//  copyright notice, this list of conditions and the following disclaimer</span>
00013 <span class="comment">//  in the documentation and/or other materials provided with the</span>
00014 <span class="comment">//  distribution.</span>
00015 <span class="comment">//  *       Neither the name of Gonzalo Garramuno nor the names of</span>
00016 <span class="comment">//  its other contributors may be used to endorse or promote products derived</span>
00017 <span class="comment">//  from this software without specific prior written permission. </span>
00018 <span class="comment">//</span>
00019 <span class="comment">//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
00020 <span class="comment">//  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
00021 <span class="comment">//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
00022 <span class="comment">//  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
00023 <span class="comment">//  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
00024 <span class="comment">//  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
00025 <span class="comment">//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
00026 <span class="comment">//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
00027 <span class="comment">//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
00028 <span class="comment">//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
00029 <span class="comment">//  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00030 <span class="comment">//</span>
00031 
00032 <span class="comment">//</span>
00033 <span class="comment">// mrCache.h</span>
00034 <span class="comment">//</span>
00035 <span class="comment">// A simple ray caching mechanism, mainly used to 'bake' reflection</span>
00036 <span class="comment">// and refraction at triangle vertex points and gourad interpolate the</span>
00037 <span class="comment">// results.  This is still somewhat experimental as the quality still</span>
00038 <span class="comment">// leaves quite a lot to be desired.</span>
00039 <span class="comment">//</span>
00040 <span class="preprocessor">#ifndef mrCache_h</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define mrCache_h</span>
00042 <span class="preprocessor"></span>
00043 
00044 <span class="preprocessor">#include &lt;map&gt;</span>
00045 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00046 
00047 <span class="preprocessor">#ifndef mrMemory_h</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="mrMemory_8h.html">mrMemory.h</a>"</span>
00049 <span class="preprocessor">#endif</span>
00050 <span class="preprocessor"></span>
00051 <span class="preprocessor">#ifndef mrSampler_h</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="mrSampler_8h.html">mrSampler.h</a>"</span>
00053 <span class="preprocessor">#endif</span>
00054 <span class="preprocessor"></span>
00055 
00056 <span class="preprocessor">#ifndef mrColor_h</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="mrColor_8h.html">mrColor.h</a>"</span>
00058 <span class="preprocessor">#endif</span>
00059 <span class="preprocessor"></span>
00060 
00061 <span class="preprocessor">#ifndef mrDerivs_h</span>
00062 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="mrDerivs_8h.html">mrDerivs.h</a>"</span>
00063 <span class="preprocessor">#endif</span>
00064 <span class="preprocessor"></span>
00065 
00066 <span class="preprocessor">#ifndef mrFunctors_h</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="mrFunctors_8h.html">mrFunctors.h</a>"</span>
00068 <span class="preprocessor">#endif</span>
00069 <span class="preprocessor"></span>
00070 
00071 
00072 <a class="code" href="mrMacros_8h.html#a0">BEGIN_NAMESPACE</a>( mr )
00073 
00074 
<a name="l00075"></a><a class="code" href="namespacemr.html#a2">00075</a> <span class="keyword">typedef</span> std::map&lt; vector, color*, lessXYZOp &gt; <a class="code" href="namespacemr.html#a2">vertex_color_cache</a>;
00076 
00140 
<a name="l00141"></a><a class="code" href="classmr_1_1TriangleVertexCache.html">00141</a> <span class="keyword">class </span><a class="code" href="classmr_1_1TriangleVertexCache.html">TriangleVertexCache</a>
00142 {
00143 
00144   miLock   m_lock;
00145   <a class="code" href="namespacemr.html#a2">vertex_color_cache</a> cache;
00146 
00147   miVector R;
00148   miVector p[3];
00149 
00150   <span class="keywordtype">void</span> deleteData()
00151   {
00152     std::for_each( cache.begin(), cache.end(), <a class="code" href="structmr_1_1deleteMapIteratorData.html">deleteMapIteratorData</a>() );
00153   }
00154 
00155   <span class="keywordtype">void</span> clear()
00156   {
00157     deleteData();
00158     cache.clear();
00159     mi_delete_lock( &amp;m_lock );
00160   }
00161 
00162 
00163   <span class="keywordtype">void</span> cache_reflection( miState* <span class="keyword">const</span> state,
00164                          <span class="keyword">const</span> miUint samples,
00165                          <span class="keyword">const</span> miScalar cosAngle,
00166                          <span class="keyword">const</span> miVector&amp; <a class="code" href="mrRman__macros_8h.html#a3">P</a>,
00167                          <span class="keyword">const</span> miVector&amp; <a class="code" href="mrRman__macros_8h.html#a4">N</a>)
00168   {
00169     vertex_color_cache::iterator i = cache.find( <a class="code" href="mrRman__macros_8h.html#a3">P</a> );
00170     <span class="keywordflow">if</span> ( i == cache.end() ) 
00171       {
00172 
00173         <span class="comment">// Calculate reflection dir</span>
00174         miVector orig_I  = state-&gt;dir;
00175         miVector orig_N  = state-&gt;normal;
00176         miVector orig_P  = state-&gt;point;
00177         miScalar orig_ND = state-&gt;dot_nd;
00178 
00179         state-&gt;normal      = <a class="code" href="mrRman__macros_8h.html#a4">N</a>;
00180         state-&gt;point       = <a class="code" href="mrRman__macros_8h.html#a3">P</a>;
00181         state-&gt;dir         = <a class="code" href="mrRman__macros_8h.html#a3">P</a> - state-&gt;org;
00182         mi_vector_normalize(&amp;state-&gt;normal);
00183         mi_vector_normalize(&amp;state-&gt;dir);
00184         state-&gt;dot_nd = mi_vector_dot(&amp;state-&gt;dir, &amp;state-&gt;normal);
00185 
00186         mi_reflection_dir( &amp;R, const_cast&lt;miState*&gt;(state) );
00187 
00188 
00189 
00190         <a class="code" href="classmr_1_1sphereSampler.html">sphereSampler</a> g( R, samples, cosAngle );
00191 
00192         <a class="code" href="structmr_1_1color.html">color</a>* sum = <span class="keyword">new</span> <a class="code" href="structmr_1_1color.html">color</a>;
00193         miColor hitColor;
00194         <span class="keywordflow">while</span> ( g.<a class="code" href="classmr_1_1sphereSampler.html#a4">uniform</a>( state ) )
00195           {
00196             miVector&amp; d = g.<a class="code" href="structmr_1_1sampler3D.html#a3">direction</a>();
00197             mi_vector_normalize(&amp;d);
00198             <span class="keywordflow">if</span> ( mi_vector_dot(&amp;d,&amp;state-&gt;normal) &lt; 0.0f ) <span class="keywordflow">continue</span>;
00199             <span class="keywordflow">if</span> ( mi_trace_reflection( &amp;hitColor, state, &amp;d ) )
00200               {
00201                 *sum   += hitColor;
00202                 sum-&gt;a += hitColor.a;
00203               }
00204           }
00205 
00206         state-&gt;dir         = orig_I;
00207         state-&gt;point       = orig_P;
00208         state-&gt;normal      = orig_N;
00209         state-&gt;dot_nd      = orig_ND;
00210 
00211         <span class="keyword">register</span> miScalar t = 1.0f / g.<a class="code" href="structmr_1_1sampler.html#a3">count</a>();
00212         *sum   *= t;
00213         sum-&gt;a *= t;
00214 
00215         cache.insert( std::make_pair( <a class="code" href="mrRman__macros_8h.html#a3">P</a>, sum ) );
00216 
00217       }
00218   }
00219 
00220 
00221 
00222   <span class="keywordtype">void</span> cache_refraction( miState* <span class="keyword">const</span> state,
00223                          <span class="keyword">const</span> miUint samples,
00224                          <span class="keyword">const</span> miScalar cosAngle,
00225                          <span class="keyword">const</span> miVector&amp; <a class="code" href="mrRman__macros_8h.html#a3">P</a>,
00226                          <span class="keyword">const</span> miVector&amp; <a class="code" href="mrRman__macros_8h.html#a4">N</a> )
00227   {
00228     vertex_color_cache::iterator i = cache.find( <a class="code" href="mrRman__macros_8h.html#a3">P</a> );
00229     <span class="keywordflow">if</span> ( i == cache.end() ) 
00230       {
00231         miVector orig_I  = state-&gt;dir;
00232         miVector orig_N  = state-&gt;normal;
00233         miVector orig_P  = state-&gt;point;
00234         miScalar orig_ND = state-&gt;dot_nd;
00235 
00236         <span class="comment">// Calculate refraction dir</span>
00237         state-&gt;normal = <a class="code" href="mrRman__macros_8h.html#a4">N</a>;
00238         state-&gt;point  = <a class="code" href="mrRman__macros_8h.html#a3">P</a>;
00239         state-&gt;dir    = <a class="code" href="mrRman__macros_8h.html#a3">P</a> - state-&gt;org;
00240         mi_vector_normalize(&amp;state-&gt;normal);
00241         mi_vector_normalize(&amp;state-&gt;dir);
00242         state-&gt;dot_nd = mi_vector_dot(&amp;state-&gt;dir, &amp;state-&gt;normal);
00243 
00244         mi_refraction_dir( &amp;R, const_cast&lt;miState*&gt;(state),
00245                            state-&gt;ior_in, state-&gt;ior );
00246 
00247         <a class="code" href="classmr_1_1sphereSampler.html">sphereSampler</a> g( R, samples, cosAngle );
00248 
00249         <a class="code" href="structmr_1_1color.html">color</a>* sum = <span class="keyword">new</span> <a class="code" href="structmr_1_1color.html">color</a>;
00250         miColor hitColor;
00251         <span class="keywordflow">while</span> ( g.<a class="code" href="classmr_1_1sphereSampler.html#a4">uniform</a>( state ) )
00252           {
00253             <span class="keywordflow">if</span> ( mi_trace_refraction( &amp;hitColor, state, &amp;g.<a class="code" href="structmr_1_1sampler3D.html#a3">direction</a>() ) )
00254               {
00255                 *sum   += hitColor;
00256                 sum-&gt;a += hitColor.a;
00257               }
00258           }
00259 
00260         <span class="keyword">register</span> miScalar t = 1.0f / g.<a class="code" href="structmr_1_1sampler.html#a3">count</a>();
00261         *sum   *= t;
00262         sum-&gt;a *= t;
00263 
00264         state-&gt;dir         = orig_I;
00265         state-&gt;point       = orig_P;
00266         state-&gt;normal      = orig_N;
00267         state-&gt;dot_nd      = orig_ND;
00268 
00269         cache.insert( std::make_pair( <a class="code" href="mrRman__macros_8h.html#a3">P</a>, sum ) );
00270       }
00271 
00272   }
00273 
00274 
00275 <span class="keyword">private</span>:
00276   <a class="code" href="classmr_1_1TriangleVertexCache.html">TriangleVertexCache</a>( <span class="keyword">const</span> <a class="code" href="classmr_1_1TriangleVertexCache.html">TriangleVertexCache</a>&amp; b ) {};
00277 
00278 <span class="keyword">public</span>:
<a name="l00279"></a><a class="code" href="classmr_1_1TriangleVertexCache.html#a0">00279</a>   <a class="code" href="classmr_1_1TriangleVertexCache.html">TriangleVertexCache</a>()  
00280   {
00281     mi_init_lock( &amp;m_lock );
00282   };
00283 
<a name="l00284"></a><a class="code" href="classmr_1_1TriangleVertexCache.html#a1">00284</a>   ~<a class="code" href="classmr_1_1TriangleVertexCache.html">TriangleVertexCache</a>() { clear(); };
00285 
<a name="l00286"></a><a class="code" href="classmr_1_1TriangleVertexCache.html#a2">00286</a>   <span class="keywordtype">void</span> lock()
00287   {
00288     mi_lock( m_lock );
00289   }
00290 
<a name="l00291"></a><a class="code" href="classmr_1_1TriangleVertexCache.html#a3">00291</a>   <span class="keywordtype">void</span> unlock()
00292   {
00293     mi_unlock( m_lock );
00294   }
00295 
<a name="l00296"></a><a class="code" href="classmr_1_1TriangleVertexCache.html#a4">00296</a>   <span class="keywordtype">void</span> reflection( <span class="keyword">const</span> miState* <span class="keyword">const</span> state,
00297                    <span class="keyword">const</span> miUint samples,
00298                    <span class="keyword">const</span> miScalar cosAngle = 0.1f )
00299   {
00300     <span class="comment">// Get triangle vertices + normals</span>
00301     miVector* po[3], *no[3];
00302     miVector   n[3];
00303     mi_tri_vectors(const_cast&lt;miState*&gt;(state), <span class="charliteral">'p'</span>, 0, 
00304                    &amp;po[0], &amp;po[1], &amp;po[2]);
00305     mi_point_from_object( const_cast&lt;miState*&gt;(state), &amp;p[0], po[0] );
00306     mi_point_from_object( const_cast&lt;miState*&gt;(state), &amp;p[1], po[1] );
00307     mi_point_from_object( const_cast&lt;miState*&gt;(state), &amp;p[2], po[2] );
00308     mi_tri_vectors(const_cast&lt;miState*&gt;(state), <span class="charliteral">'n'</span>, 0, 
00309                    &amp;no[0], &amp;no[1], &amp;no[2]);
00310     mi_normal_from_object( const_cast&lt;miState*&gt;(state), &amp;n[0], no[0] );
00311     mi_normal_from_object( const_cast&lt;miState*&gt;(state), &amp;n[1], no[1] );
00312     mi_normal_from_object( const_cast&lt;miState*&gt;(state), &amp;n[2], no[2] );
00313 
00314     <span class="comment">// Now cache</span>
00315     <span class="keywordflow">for</span> (<span class="keywordtype">char</span> i = 0; i &lt; 3; ++i )
00316       cache_reflection( const_cast&lt;miState*&gt;(state), samples, cosAngle, 
00317                         p[i], n[i] );
00318 
00319   }
00320 
00321 
<a name="l00322"></a><a class="code" href="classmr_1_1TriangleVertexCache.html#a5">00322</a>   <span class="keywordtype">void</span> refraction( <span class="keyword">const</span> miState* <span class="keyword">const</span> state, 
00323                    <span class="keyword">const</span> miUint samples,
00324                    <span class="keyword">const</span> miScalar cosAngle = 0.1f )
00325   {
00326     <span class="comment">// Get triangle vertices + normals</span>
00327     miVector* po[3], *no[3];
00328     miVector   n[3];
00329     mi_tri_vectors(const_cast&lt;miState*&gt;(state), <span class="charliteral">'p'</span>, 0, 
00330                    &amp;po[0], &amp;po[1], &amp;po[2]);
00331     mi_point_from_object( const_cast&lt;miState*&gt;(state), &amp;p[0], po[0] );
00332     mi_point_from_object( const_cast&lt;miState*&gt;(state), &amp;p[1], po[1] );
00333     mi_point_from_object( const_cast&lt;miState*&gt;(state), &amp;p[2], po[2] );
00334     mi_tri_vectors(const_cast&lt;miState*&gt;(state), <span class="charliteral">'n'</span>, 0, 
00335                    &amp;no[0], &amp;no[1], &amp;no[2]);
00336     mi_normal_from_object( const_cast&lt;miState*&gt;(state), &amp;n[0], no[0] );
00337     mi_normal_from_object( const_cast&lt;miState*&gt;(state), &amp;n[1], no[1] );
00338     mi_normal_from_object( const_cast&lt;miState*&gt;(state), &amp;n[2], no[2] );
00339       
00340     <span class="comment">// Now cache</span>
00341     <span class="keywordflow">for</span> (<span class="keywordtype">char</span> i = 0; i &lt; 3; ++i )
00342       cache_refraction( const_cast&lt;miState*&gt;(state), samples, cosAngle, 
00343                         p[i], n[i] );
00344 
00345   }
00346 
00347 
<a name="l00348"></a><a class="code" href="classmr_1_1TriangleVertexCache.html#a6">00348</a>   <a class="code" href="structmr_1_1color.html">color</a> interpolate( <span class="keyword">const</span> miState* <span class="keyword">const</span> state )
00349   {
00350     vertex_color_cache::iterator v0 = cache.find( p[0] );
00351     vertex_color_cache::iterator v1 = cache.find( p[1] );
00352     vertex_color_cache::iterator v2 = cache.find( p[2] );
00353 
00354     <span class="keyword">const</span> miColor&amp; c0 = *(v0-&gt;second);
00355     <span class="keyword">const</span> miColor&amp; c1 = *(v1-&gt;second);
00356     <span class="keyword">const</span> miColor&amp; c2 = *(v2-&gt;second);
00357       
00358     <span class="keywordflow">return</span> <a class="code" href="structmr_1_1color.html">color</a>( c0 * state-&gt;bary[0] +
00359                   c1 * state-&gt;bary[1] +
00360                   c2 * state-&gt;bary[2] );
00361   }
00362     
00363 
00364 }; <span class="comment">// triangleVertexCache</span>
00365 
00366 
00367 
00368 
00369 
00370 
00371 
00372 
<a name="l00373"></a><a class="code" href="namespacemr.html#a3">00373</a> <span class="keyword">static</span> <span class="keyword">const</span> miScalar <a class="code" href="namespacemr.html#a3">kNotCached</a> = -255.0f;
00374 
<a name="l00381"></a><a class="code" href="classmr_1_1UVCache.html">00381</a> <span class="keyword">class </span><a class="code" href="classmr_1_1UVCache.html">UVCache</a>
00382 {
00383 
00384   miColor* cache;
00385 
00386   miUint width, height; <span class="comment">// resolution of map cache</span>
00387 
00388   miLock   m_lock;
00389   miScalar cosAngle;
00390   miUint    samples;
00391   miVector* t[3];
00392 
00393   <span class="comment">// Auxiliaries used to compute map/triangle intersections</span>
00394   <span class="keyword">typedef</span> <span class="keyword">struct </span>Line2d {
00395     <span class="keywordtype">float</span>               s;      <span class="comment">/* slope */</span>
00396     <span class="keywordtype">float</span>               o;      <span class="comment">/* offset */</span>
00397   } Line2d;
00398 
00399   Line2d     line[3];
00400   Line2d*    left[2], *right[2];
00401   miMatrix   pixel_to_bary;
00402   miVector2d uv;
00403 
00404   <span class="keywordtype">void</span> deleteData()
00405   {
00406     <span class="keyword">delete</span> [] cache;
00407   }
00408 
00409   <span class="keywordtype">void</span> clear()
00410   {
00411     deleteData();
00412     mi_delete_lock( &amp;m_lock );
00413   }
00414 
00415 
00416   <span class="keywordtype">void</span> cache_reflection( 
00417                         miState* <span class="keyword">const</span> state
00418                         )
00419   {
00420     miVector R;
00421     mi_reflection_dir( &amp;R, const_cast&lt;miState*&gt;(state) );
00422 
00423 
00424     <a class="code" href="classmr_1_1sphereSampler.html">sphereSampler</a> g( R, samples, cosAngle );
00425 
00426     <span class="keywordtype">unsigned</span> idx = static_cast&lt; unsigned &gt;(uv.u + uv.v * width);
00427     <a class="code" href="structmr_1_1color.html">color</a>* sum = (<a class="code" href="structmr_1_1color.html">color</a>*)( cache + idx );
00428     sum-&gt;r = sum-&gt;g = sum-&gt;b = sum-&gt;a = 0.0f;
00429 
00430     miColor hitColor;
00431     <span class="keywordflow">while</span> ( g.<a class="code" href="classmr_1_1sphereSampler.html#a4">uniform</a>( state ) )
00432       {
00433         miVector&amp; d = g.<a class="code" href="structmr_1_1sampler3D.html#a3">direction</a>();
00434         mi_vector_normalize(&amp;d);
00435         <span class="keywordflow">if</span> ( mi_vector_dot(&amp;d,&amp;state-&gt;normal) &lt; 0.0f ) <span class="keywordflow">continue</span>;
00436         <span class="keywordflow">if</span> ( mi_trace_reflection( &amp;hitColor, state, &amp;d ) )
00437           {
00438             *sum   += hitColor;
00439             sum-&gt;a += hitColor.a;
00440           }
00441       }
00442 
00443 
00444     <span class="keyword">register</span> miScalar t = 1.0f / g.<a class="code" href="structmr_1_1sampler.html#a3">count</a>();
00445     *sum   *= t;
00446     sum-&gt;a *= t;
00447 
00448   }
00449 
00450 
00451 
00452   <span class="keywordtype">void</span> cache_refraction( miState* <span class="keyword">const</span> state )
00453   {
00454         miVector R;
00455         mi_refraction_dir( &amp;R, const_cast&lt;miState*&gt;(state),
00456                            state-&gt;ior_in, state-&gt;ior );
00457 
00458         <a class="code" href="classmr_1_1sphereSampler.html">sphereSampler</a> g( R, samples, cosAngle );
00459 
00460         <a class="code" href="structmr_1_1color.html">color</a>* sum = <span class="keyword">new</span> <a class="code" href="structmr_1_1color.html">color</a>;
00461         miColor hitColor;
00462         <span class="keywordflow">while</span> ( g.<a class="code" href="classmr_1_1sphereSampler.html#a4">uniform</a>( state ) )
00463           {
00464             <span class="keywordflow">if</span> ( mi_trace_refraction( &amp;hitColor, state, &amp;g.<a class="code" href="structmr_1_1sampler3D.html#a3">direction</a>() ) )
00465               {
00466                 *sum   += hitColor;
00467                 sum-&gt;a += hitColor.a;
00468               }
00469           }
00470 
00471         <span class="keyword">register</span> miScalar t = 1.0f / g.<a class="code" href="structmr_1_1sampler.html#a3">count</a>();
00472         *sum   *= t;
00473         sum-&gt;a *= t;
00474 
00475   }
00476 
00477   <span class="keyword">static</span> <span class="keywordtype">void</span> mib_lightmap_bary_fixup(  miVector* <span class="keyword">const</span> bary)
00478   {
00479     <span class="keywordtype">float</span> s = (1.0f - bary-&gt;x - bary-&gt;y - bary-&gt;z)/3.0f;
00480     bary-&gt;x += s;
00481     bary-&gt;y += s;
00482 
00483     <span class="comment">/* now clip coordinates */</span>
00484     <span class="keywordflow">if</span> (bary-&gt;x &lt; 0.0f)
00485       bary-&gt;x = 0.0f;
00486     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bary-&gt;x &gt; 1.0f)
00487       bary-&gt;x = 1.0f;
00488 
00489     <span class="keywordflow">if</span> (bary-&gt;y &lt; 0.0f)
00490       bary-&gt;y = 0.0f;
00491     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bary-&gt;y + bary-&gt;x &gt; 1.0f)
00492       bary-&gt;y = 1.0f-bary-&gt;x;
00493 
00494     <span class="comment">/* Finally, compute the dependent z */</span>
00495     bary-&gt;z = 1.0f - bary-&gt;x - bary-&gt;y;
00496   }
00497 
00498   <span class="keyword">inline</span> 
00499   <span class="keywordtype">void</span> mib_lightmap_combine_vectors(
00500                                     miVector    *res,
00501                                     miVector <span class="keyword">const</span>      *a,
00502                                     miVector <span class="keyword">const</span>      *b,
00503                                     miVector <span class="keyword">const</span>      *c,
00504                                     miVector <span class="keyword">const</span>      *bary)
00505   {
00506     res-&gt;x = bary-&gt;x * a-&gt;x + bary-&gt;y * b-&gt;x + bary-&gt;z * c-&gt;x;
00507     res-&gt;y = bary-&gt;x * a-&gt;y + bary-&gt;y * b-&gt;y + bary-&gt;z * c-&gt;y;
00508     res-&gt;z = bary-&gt;x * a-&gt;z + bary-&gt;y * b-&gt;z + bary-&gt;z * c-&gt;z;
00509   }
00510 
00511 
00512 <span class="keyword">private</span>:
00513   <a class="code" href="classmr_1_1UVCache.html">UVCache</a>( ) {};
00514   <a class="code" href="classmr_1_1UVCache.html">UVCache</a>( <span class="keyword">const</span> <a class="code" href="classmr_1_1UVCache.html">UVCache</a>&amp; b ) {};
00515 
00516 <span class="keyword">public</span>:
<a name="l00517"></a><a class="code" href="classmr_1_1UVCache.html#a0">00517</a>   <a class="code" href="classmr_1_1UVCache.html">UVCache</a>( <span class="keyword">const</span> miUint xres, <span class="keyword">const</span> miUint yres ) :
00518      width( xres ),
00519      height( yres ),
00520      cache( new miColor[ xres * yres ] )
00521   {
00522     miColor* x = cache;
00523     <span class="keywordtype">unsigned</span> size = xres * yres;
00524     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0; i &lt; size; ++i, ++x )
00525       {
00526         x-&gt;r = <a class="code" href="namespacemr.html#a3">kNotCached</a>; x-&gt;g = x-&gt;b = x-&gt;a = 0.0f; 
00527       }
00528 
00529     mi_init_lock( &amp;m_lock );
00530   };
00531 
<a name="l00532"></a><a class="code" href="classmr_1_1UVCache.html#a1">00532</a>   ~<a class="code" href="classmr_1_1UVCache.html">UVCache</a>() { clear(); };
00533 
<a name="l00534"></a><a class="code" href="classmr_1_1UVCache.html#a2">00534</a>   <span class="keywordtype">void</span> lock()
00535   {
00536   }
00537 
<a name="l00538"></a><a class="code" href="classmr_1_1UVCache.html#a3">00538</a>   <span class="keywordtype">void</span> unlock()
00539   {
00540   }
00541 
<a name="l00542"></a><a class="code" href="classmr_1_1UVCache.html#a4">00542</a>   <span class="keywordtype">void</span> reflection( miState* <span class="keyword">const</span> state,
00543                    <span class="keyword">const</span> miUint numSamples,
00544                    <span class="keyword">const</span> miScalar cosine = 0.1f )
00545   {
00546     mi_lock( m_lock );
00547 
00548     samples  = numSamples;
00549     cosAngle = cosine;
00550     
00551     miVector* po[3], *no[3];
00552     miVector p[3], n[3];
00553     mi_tri_vectors(const_cast&lt;miState*&gt;(state), <span class="charliteral">'p'</span>, 0, &amp;po[0], &amp;po[1], &amp;po[2]);
00554     mi_point_from_object( state, &amp;p[0], po[0] );
00555     mi_point_from_object( state, &amp;p[1], po[1] );
00556     mi_point_from_object( state, &amp;p[2], po[2] );
00557     mi_tri_vectors(const_cast&lt;miState*&gt;(state), <span class="charliteral">'n'</span>, 0, &amp;no[0], &amp;no[1], &amp;no[2]);
00558     mi_normal_from_object( state, &amp;n[0], no[0] );
00559     mi_normal_from_object( state, &amp;n[1], no[1] );
00560     mi_normal_from_object( state, &amp;n[2], no[2] );
00561     mi_tri_vectors(const_cast&lt;miState*&gt;(state), <span class="charliteral">'t'</span>, 0, &amp;t[0], &amp;t[1], &amp;t[2]);
00562 
00563     miVector2d                  pixa, pixb, pixc;
00564     pixa.u = t[0]-&gt;x * width  - 0.5f;
00565     pixb.u = t[1]-&gt;x * width  - 0.5f;
00566     pixc.u = t[2]-&gt;x * width  - 0.5f;
00567     pixa.v = t[0]-&gt;y * height - 0.5f;
00568     pixb.v = t[1]-&gt;y * height - 0.5f;
00569     pixc.v = t[2]-&gt;y * height - 0.5f;
00570 
00571 
00572     miVector2d <span class="keyword">const</span>                    *pix_y[3], *tmp;
00573     <span class="comment">/* sort vertices in y increasing order */</span>
00574     pix_y[0] = &amp;pixa;
00575     pix_y[1] = &amp;pixb;
00576     pix_y[2] = &amp;pixc;
00577     <span class="keywordflow">if</span> (pix_y[0]-&gt;v &gt; pix_y[1]-&gt;v) {
00578       tmp = pix_y[0];
00579       pix_y[0] = pix_y[1];
00580       pix_y[1] = tmp;
00581     }
00582     <span class="keywordflow">if</span> (pix_y[1]-&gt;v &gt; pix_y[2]-&gt;v) {
00583       tmp = pix_y[1];
00584       pix_y[1] = pix_y[2];
00585       pix_y[2] = tmp;
00586     }
00587     <span class="keywordflow">if</span> (pix_y[0]-&gt;v &gt; pix_y[1]-&gt;v) {
00588       tmp = pix_y[0];
00589       pix_y[0] = pix_y[1];
00590       pix_y[1] = tmp;
00591     }
00592 
00593     <span class="comment">/* avoid empty triangles */</span>
00594     <span class="keywordflow">if</span> (pix_y[0]-&gt;v &gt;= pix_y[2]-&gt;v)
00595       <span class="keywordflow">return</span>;
00596 
00597 
00598     line[0].s = (pix_y[1]-&gt;u-pix_y[0]-&gt;u)/(pix_y[1]-&gt;v-pix_y[0]-&gt;v);
00599     line[0].o = pix_y[0]-&gt;u - pix_y[0]-&gt;v*line[0].s;
00600 
00601     line[1].s = (pix_y[2]-&gt;u-pix_y[1]-&gt;u)/(pix_y[2]-&gt;v-pix_y[1]-&gt;v);
00602     line[1].o = pix_y[1]-&gt;u - pix_y[1]-&gt;v*line[1].s;
00603 
00604     line[2].s = (pix_y[2]-&gt;u-pix_y[0]-&gt;u)/(pix_y[2]-&gt;v-pix_y[0]-&gt;v);
00605     line[2].o = pix_y[0]-&gt;u - pix_y[0]-&gt;v*line[2].s;
00606 
00607     <span class="comment">/* remove degenerate line */</span>
00608     <span class="keywordtype">bool</span> long_right;
00609     <span class="keywordflow">if</span> (pix_y[1]-&gt;v == pix_y[0]-&gt;v) {
00610       line[0] = line[1];
00611       long_right = line[1].s &gt; line[2].s;
00612     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pix_y[2]-&gt;v == pix_y[1]-&gt;v) {
00613       line[1] = line[0];
00614       long_right = line[0].s &lt; line[2].s;
00615     } <span class="keywordflow">else</span>
00616       long_right = line[0].s &lt; line[2].s;
00617 
00618 
00619     <span class="comment">/* arrange the lines */</span>
00620     <span class="keywordflow">if</span> (long_right) {
00621       left[0]  = &amp;line[0];
00622       left[1]  = &amp;line[1];
00623       right[0] = &amp;line[2];
00624       right[1] = &amp;line[2];
00625     } <span class="keywordflow">else</span> {
00626       left[0]  = &amp;line[2];
00627       left[1]  = &amp;line[2];
00628       right[0] = &amp;line[0];
00629       right[1] = &amp;line[1];
00630     }
00631 
00632     <span class="comment">/*</span>
00633 <span class="comment">     * pixel to barycentric coordinate transform. This is a 2D homogeneous</span>
00634 <span class="comment">     * problem (to allow for translation) so the third component is set to</span>
00635 <span class="comment">     * 1 and we have a 3-by-3 matrix equation.</span>
00636 <span class="comment">     */</span>
00637     miMatrix tmp1, tmp2;
00638     mi_matrix_ident(tmp1);
00639     tmp1[ 0] = pixa.u;
00640     tmp1[ 4] = pixb.u;
00641     tmp1[ 8] = pixc.u;
00642     tmp1[ 1] = pixa.v;
00643     tmp1[ 5] = pixb.v;
00644     tmp1[ 9] = pixc.v;
00645     tmp1[ 2] = 1.0f;
00646     tmp1[ 6] = 1.0f;
00647     tmp1[10] = 1.0f;
00648     mi_matrix_ident(tmp2);      <span class="comment">/* corresponds to barycentric vectors */</span>
00649     <span class="comment">/* solve pix * pix_to_space = bary */</span>
00650     <span class="keywordflow">if</span> (!mi_matrix_solve(pixel_to_bary, tmp1, tmp2, 4))
00651       <span class="keywordflow">return</span>;
00652 
00653     <span class="keywordtype">float</span> y_min = <a class="code" href="structmr_1_1math.html">math&lt;float&gt;::floor</a>(pix_y[0]-&gt;<a class="code" href="mrRman__macros_8h.html#a10">v</a>);
00654     <span class="keywordflow">if</span> (y_min &lt; 0)  y_min = 0;
00655 
00656     <span class="keywordtype">float</span> y_max = <a class="code" href="structmr_1_1math.html">math&lt;float&gt;::ceil</a>(pix_y[2]-&gt;<a class="code" href="mrRman__macros_8h.html#a10">v</a>);
00657     <span class="keywordflow">if</span> (y_max &gt;= height) y_max = static_cast&lt;float&gt;(height-1);
00658 
00659     miState oldState = *state;
00660 
00661 
00662     miVector pt;
00663     pt.z = 1.0f;
00664 
00665     <span class="keywordflow">for</span> (uv.v=y_min; uv.v &lt;= y_max; ++uv.v) {
00666       <span class="keywordtype">float</span>     left_x, right_x;
00667       <span class="keywordtype">int</span>       i = uv.v &lt; pix_y[1]-&gt;v ? 0 : 1;
00668 
00669       <span class="comment">/* Loop over texture X range */</span>
00670       left_x  = math&lt;float&gt;::floor(left[i]-&gt;o  + uv.v*left[i]-&gt;s);
00671       <span class="keywordflow">if</span> (left_x&lt;0) left_x = 0;
00672 
00673       right_x = math&lt;float&gt;::ceil(right[i]-&gt;o + uv.v*right[i]-&gt;s);
00674       <span class="keywordflow">if</span> (right_x&gt;=width) right_x = static_cast&lt;float&gt;(width-1);
00675 
00676 
00677       <span class="keywordflow">for</span> (uv.u=left_x; uv.u &lt;= right_x; ++uv.u) {
00678         <span class="comment">//</span>
00679         <span class="comment">// do check if already on cache here...</span>
00680         <span class="comment">//</span>
00681         <span class="keywordtype">unsigned</span> idx = static_cast&lt;unsigned&gt;(uv.u + uv.v * width);
00682         <span class="keywordflow">if</span> ( cache[idx].r != <a class="code" href="namespacemr.html#a3">kNotCached</a> ) <span class="keywordflow">continue</span>;
00683 
00684         miVector bary;
00685         pt.x = uv.u; pt.y = uv.v;
00686         mi_vector_transform(&amp;bary, &amp;pt, pixel_to_bary);
00687 
00688 
00689         <span class="comment">/* constrain barycentric coordinates to triangle */</span>
00690         mib_lightmap_bary_fixup(&amp;bary);
00691 
00692 
00693         <span class="comment">/* pixel center is inside triangle */</span>
00694         mib_lightmap_combine_vectors(&amp;state-&gt;point, &amp;p[0], &amp;p[1], &amp;p[2],
00695                                      &amp;bary);
00696         mib_lightmap_combine_vectors(&amp;state-&gt;normal, &amp;n[0], &amp;n[1], &amp;n[2], 
00697                                      &amp;bary);
00698         mi_vector_normalize(&amp;state-&gt;normal);
00699 
00700 
00701         state-&gt;dir.x = state-&gt;point.x - state-&gt;org.x;
00702         state-&gt;dir.y = state-&gt;point.y - state-&gt;org.y;
00703         state-&gt;dir.z = state-&gt;point.z - state-&gt;org.z;
00704         mi_vector_normalize(&amp;state-&gt;dir);
00705 
00706         state-&gt;dot_nd = mi_vector_dot(&amp;state-&gt;dir, &amp;state-&gt;normal);
00707 
00708         <span class="comment">/* Fill out state-&gt;tex_list */</span>
00709         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; ; ++j) {
00710           miVector *ta, *tb, *tc;
00711           <span class="keywordflow">if</span> (!mi_tri_vectors(state, <span class="charliteral">'t'</span>, j, &amp;ta, &amp;tb, &amp;tc))
00712             <span class="keywordflow">break</span>;
00713           mib_lightmap_combine_vectors(&amp;state-&gt;tex_list[j],
00714                                        ta, tb, tc, &amp;bary);
00715         }
00716 
00717         <span class="keywordflow">if</span> (state-&gt;options-&gt;shadow &amp;&amp; state-&gt;type != miRAY_SHADOW ) {
00718           <span class="keywordtype">double</span> d_shadow_tol, tmp_d;
00719 
00720           d_shadow_tol = mi_vector_dot_d(&amp;state-&gt;normal, &amp;p[0]);
00721           tmp_d = mi_vector_dot_d(&amp;state-&gt;normal, &amp;p[1]);
00722           <span class="keywordflow">if</span> (d_shadow_tol &lt; tmp_d)
00723             d_shadow_tol = tmp_d;
00724           tmp_d = mi_vector_dot_d(&amp;state-&gt;normal, &amp;p[2]);
00725           <span class="keywordflow">if</span> (d_shadow_tol &lt; tmp_d)
00726             d_shadow_tol = tmp_d;
00727           state-&gt;shadow_tol = d_shadow_tol
00728             - mi_vector_dot_d(&amp;state-&gt;normal, &amp;state-&gt;point);
00729         }
00730 
00731         <span class="comment">//state is set... sample now</span>
00732         cache_reflection( state );
00733       }
00734     }
00735 
00736 
00737     *state = oldState;
00738     mi_unlock( m_lock );
00739 
00740   }
00741 
00742 
<a name="l00743"></a><a class="code" href="classmr_1_1UVCache.html#a5">00743</a>   <span class="keywordtype">void</span> refraction( <span class="keyword">const</span> miState* <span class="keyword">const</span> state, 
00744                    <span class="keyword">const</span> miUint numSamples,
00745                    <span class="keyword">const</span> miScalar cosine = 0.1f )
00746   {
00747     samples  = numSamples;
00748     cosAngle = cosine;
00749   }
00750 
00751 
<a name="l00752"></a><a class="code" href="classmr_1_1UVCache.html#a6">00752</a>   <a class="code" href="structmr_1_1color.html">color</a> interpolate( miState* <span class="keyword">const</span> state )
00753   {
00754 
00755     miVector2d  pixa;
00756     pixa.u = state-&gt;tex_list[0].x * width  - 0.5f;
00757     pixa.v = state-&gt;tex_list[0].y * height - 0.5f;
00758 
00759     <span class="keywordtype">unsigned</span> uvt[3][2];
00760     uvt[0][0] = static_cast&lt;unsigned&gt;(<a class="code" href="namespacemr.html#a62">round</a>( pixa.u ));
00761     uvt[0][1] = static_cast&lt;unsigned&gt;(<a class="code" href="namespacemr.html#a62">round</a>( pixa.v ));
00762     <span class="keywordflow">if</span> ( uvt[0][0] &gt;= width  ) uvt[0][0] = width-1;
00763     <span class="keywordflow">if</span> ( uvt[0][1] &gt;= height ) uvt[0][1] = height-1;
00764 
00765     uvt[1][0] = uvt[0][0] + 1;
00766     uvt[1][1] = uvt[0][1];
00767     <span class="keywordflow">if</span> ( uvt[1][0] &gt;= width )  uvt[1][0] = uvt[0][0];
00768 
00769     uvt[2][0] = uvt[0][0];
00770     uvt[2][1] = uvt[0][1] + 1;
00771     <span class="keywordflow">if</span> ( uvt[2][1] &gt;= height ) uvt[2][1] = uvt[0][1];
00772 
00773     <span class="keyword">const</span> miColor&amp; c0 = cache[uvt[0][0] + uvt[0][1] * width];
00774     miColor&amp; c1 = cache[uvt[1][0] + uvt[1][1] * width];
00775     miColor&amp; c2 = cache[uvt[2][0] + uvt[2][1] * width];
00776 
00777     <span class="keywordflow">if</span> (c0.r == <a class="code" href="namespacemr.html#a3">kNotCached</a>)
00778       {
00779         uv.u = static_cast&lt;float&gt;(uvt[0][0]); 
00780         uv.v = static_cast&lt;float&gt;(uvt[0][1]);
00781         cache_reflection( state );
00782       }
00783     <span class="keywordflow">if</span> (c1.r == <a class="code" href="namespacemr.html#a3">kNotCached</a>)
00784       {
00785         c1 = c0;
00786       }
00787     <span class="keywordflow">if</span> (c2.r == <a class="code" href="namespacemr.html#a3">kNotCached</a>)
00788       {
00789         c2 = c0;
00790       }
00791 
00792     <span class="keywordtype">float</span> u_amt = <a class="code" href="structmr_1_1math.html">math&lt;float&gt;::fabs</a>(pixa.u - uvt[0][0]);
00793     <span class="keywordtype">float</span> v_amt = math&lt;float&gt;::fabs(pixa.v - uvt[0][1]);
00794 
00795     <span class="keywordflow">return</span> <a class="code" href="structmr_1_1color.html">color</a>( c0 * (1.0f - u_amt - v_amt) +
00796                   c1 * u_amt + c2 * v_amt );
00797   }
00798     
00799 
00800 }; <span class="comment">// UVCache</span>
00801 
00802 
00803 
00804 
00805 
00806 
00807 
00808 <a class="code" href="mrMacros_8h.html#a1">END_NAMESPACE</a>( mr )
00809 
00810 #endif <span class="comment">// mrCache_h</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Feb 22 18:29:23 2004 for mrClasses by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
